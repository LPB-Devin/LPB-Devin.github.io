<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java学习路线</title>
    <url>/2020/02/08/hello-world/</url>
    <content><![CDATA[<p><img src="https://i.loli.net/2020/01/12/UYB9sHelnRL15XF.jpg" alt="1源码分析专题.jpg"></p>
<p><img src="https://i.loli.net/2020/01/12/JhGaO1jWexKMlwo.jpg" alt="2性能优化.jpg"></p>
<p><img src="https://i.loli.net/2020/01/12/EuNyqAFs4bBDCm6.jpg" alt="3高性能.jpg"></p>
<p><img src="https://i.loli.net/2020/01/12/dXjU35ECvplLwIG.jpg" alt="4分布式专题.jpg"></p>
]]></content>
  </entry>
  <entry>
    <title>Vue版本更新</title>
    <url>/2020/02/04/Vue/Vue%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0/</url>
    <content><![CDATA[<blockquote>
<p> 一段时间没用Vue，重新拿起来，哇擦都更新到4.x版本了……看着自己的2.9.6版本，陷入了沉思……</p>
</blockquote>
<p>从2.x更新Vue到4.x版本中，需要分两步：将旧版本卸载，再安装当前的新版本Vue，命令如下：</p>
<p>卸载旧版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall -g vue-cli</span><br><span class="line">或</span><br><span class="line">yarn global remove vue-cli</span><br></pre></td></tr></table></figure>

<p>安装新版本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g @vue&#x2F;cli</span><br><span class="line">或</span><br><span class="line">yarn global add @vue&#x2F;cli</span><br></pre></td></tr></table></figure>



]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis】Redis的内存淘汰策略</title>
    <url>/2020/01/16/Redis/%E3%80%90Redis%E3%80%91%E5%86%85%E5%AD%98%E6%95%B0%E6%8D%AE%E6%BB%A1%E4%BA%86%E4%BC%9A%E5%AE%95%E6%9C%BA%E5%90%97/</url>
    <content><![CDATA[<h2 id="带着问题学习"><a href="#带着问题学习" class="headerlink" title="带着问题学习"></a>带着问题学习</h2><p><strong>Redis数据库内存满了的话，会不会造成宕机？</strong></p>
<h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p>这问题一开始便有一坑，Redis并不会让内存数据存满这种情况发生。在使用Redis的时候，我们需要配置Redis能够使用的最大内存大小， 存到一定容量的时候还有Redis的内存淘汰策略呢，还有最近最少使用(LRU)算法进行淘汰，等等。。。 </p>
<h2 id="Redis占用内存"><a href="#Redis占用内存" class="headerlink" title="Redis占用内存"></a>Redis占用内存</h2><p>众所周知，Redis是基于内存的key-value数据库，因为系统的内存大小有限，在使用Redis的时候，可以配置Redis能使用的最大内存大小。</p>
<h3 id="配置方式"><a href="#配置方式" class="headerlink" title="配置方式"></a>配置方式</h3><ol>
<li><p>通过配置文件配置</p>
<p>通过在Redis安装目录下的redis.conf配置文件中添加以下配置，设置内存大小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;设置Redis最大占用内存大小为100M&#96;</span><br><span class="line"></span><br><span class="line">maxmemory 100mb&#96;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>redis的配置文件不一定使用的是安装目录下的redis.conf文件，启动redis服务的时候可以通过传参指定redis使用的配置文件</p>
</blockquote>
</li>
<li><p>通过命令修改</p>
<p>Redis支持运行时通过命令动态修改内存大小</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//设置Redis最大占用内存大小为100M`</span><br><span class="line">127.0.0.1:6379&gt; config set maxmemory 100mb`</span><br><span class="line"></span><br><span class="line">//获取设置的Redis能使用的最大内存大小`</span><br><span class="line">127.0.0.1:6379&gt; config get maxmemory`</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果不设置最大内存大小或者设置最大内存大小为0，在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</p>
</blockquote>
</li>
</ol>
<h2 id="Redis的内存淘汰"><a href="#Redis的内存淘汰" class="headerlink" title="Redis的内存淘汰"></a>Redis的内存淘汰</h2><p>既然可以设置Redis最大占用内存大小，那么配置的内存就有用完的时候。那在内存用完的时候，还继续往Redis里面添加数据不就没内存可用了吗？</p>
<p>实际上Redis定义了几种策略用来处理这种情况：</p>
<p><strong>noeviction(默认策略)</strong>：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</p>
<p><strong>allkeys-lru</strong>：从所有key中使用LRU算法进行淘汰</p>
<p><strong>volatile-lru</strong>：从设置了过期时间的key中使用LRU算法进行淘汰</p>
<p><strong>allkeys-random</strong>：从所有key中随机淘汰数据</p>
<p><strong>volatile-random</strong>：从设置了过期时间的key中随机淘汰</p>
<p><strong>volatile-ttl</strong>：在设置了过期时间的key中，根据key的过期时间进行淘汰，越早过期的越优先被淘汰</p>
<blockquote>
<p> 当使用<strong>volatile-lru</strong>、<strong>volatile-random</strong>、<strong>volatile-ttl</strong>这三种策略时，如果没有key可以被淘汰，则和<strong>noeviction</strong>一样返回错误 </p>
</blockquote>
<h3 id="获取和设置内存淘汰策略"><a href="#获取和设置内存淘汰策略" class="headerlink" title="获取和设置内存淘汰策略"></a>获取和设置内存淘汰策略</h3><ul>
<li><p>获取当前内存淘汰策略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config get maxmemory-policy</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过修改redis.conf文件设置淘汰策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory-policy allkeys-lru</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>通过命令修改淘汰策略</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; config set maxmemory-policy allkeys-lru`</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a><strong>LRU算法</strong></h3><h5 id="什么是LRU"><a href="#什么是LRU" class="headerlink" title="什么是LRU?"></a>什么是LRU?</h5><p>上面说到了Redis可使用最大内存使用完了，是可以使用LRU算法进行内存淘汰的，那么什么是LRU算法呢？</p>
<blockquote>
<p><strong>LRU(Least Recently Used)</strong>，即最近最少使用，是一种缓存置换算法。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。其核心思想是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p>
</blockquote>
<h3 id="LRU在Redis中的实现"><a href="#LRU在Redis中的实现" class="headerlink" title="LRU在Redis中的实现"></a><strong>LRU在Redis中的实现</strong></h3><h5 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h5><p>Redis使用的是近似LRU算法，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p>
<blockquote>
<p>可以通过maxmemory-samples参数修改采样数量：例：maxmemory-samples 10 maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法</p>
</blockquote>
<p>Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。</p>
<h5 id="Redis3-0对近似LRU的优化"><a href="#Redis3-0对近似LRU的优化" class="headerlink" title="Redis3.0对近似LRU的优化"></a>Redis3.0对近似LRU的优化</h5><p>Redis3.0对近似LRU算法进行了一些优化。新算法会维护一个候选池（大小为16），池中的数据根据访问时间进行排序，第一次随机选取的key都会放入池中，随后每次随机选取的key只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。</p>
<p>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。</p>
<h3 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a><strong>LFU算法</strong></h3><p>LFU算法是Redis4.0里面新加的一种淘汰策略。它的全称是<strong>Least Frequently Used</strong>，它的核心思想是根据key的最近被访问的频率进行淘汰，很少被访问的优先被淘汰，被访问的多的则被留下来。</p>
<p>LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。</p>
<p>LFU一共有两种策略：</p>
<p>volatile-lfu：在设置了过期时间的key中使用LFU算法淘汰key</p>
<p>allkeys-lfu：在所有的key中使用LFU算法淘汰数据</p>
<blockquote>
<p>设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两周策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错</p>
</blockquote>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap底层为什么时数组链表结构</title>
    <url>/2020/01/16/HashMap%E5%BA%95%E5%B1%82%E4%B8%BA%E4%BB%80%E4%B9%88%E6%97%B6%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>之前面试时问了HashMap的底层结构，详细见本人个人对HashMap和Hashtable底层实现的见解，入口如下：<br><a href="https://blog.csdn.net/weixin_40849588/article/details/88384922" target="_blank" rel="noopener">Java中HashMap与HashTable底层的联系与区别</a></p>
<p>之后被问到HashMap底层为什么是数组链表呢？这样的话，链表一长，在链表中查询的效率不是很低吗？<br>我：（哑了）<br>最近看到一个比较有依据的答案，在此做一下答复。</p>
<h2 id="HashMap底层为什么是数组链表呢？在链表中查询的效率不是很低吗？"><a href="#HashMap底层为什么是数组链表呢？在链表中查询的效率不是很低吗？" class="headerlink" title="HashMap底层为什么是数组链表呢？在链表中查询的效率不是很低吗？"></a>HashMap底层为什么是数组链表呢？在链表中查询的效率不是很低吗？</h2><p>在JDK1.7以及1.7版本之前，HashMap对数组元素即链表的查询确实是从头节点开始查询的，这样链表一旦长了，效率比较低也是意料之中。<br>而在1.8中对HashMap的数据结构进行了一定的优化，其中<strong>增加了一个阈值对数组元素进行判断是否有必要进行红黑树变形</strong>（红黑树是一种二叉查找树），一旦链表长度达到了阈值，其数据结构便会变形为红黑树，提高了查询效率，但插入的效率并没有链表头插法那么高，这也可能是HashMap底层为什么不用红黑树组成的数组的原因之一。<br>性能对比：</p>
<blockquote>
<ul>
<li>链表：插入复杂度O(1)，查找复杂度O(n)</li>
<li>红黑树：插入复杂度O(logn)，查找复杂度O(logn)</li>
</ul>
</blockquote>
<ul>
<li>HashMap数组元素为链表的时候，插入直接使用头插，插入复杂度O(1)；当链表较短时候，查找数据时对性能并没有什么影响，如果链表一长，查找起来就很影响性能了。 </li>
<li>在Java8中，如果链表长度到达了8个，就会转化为红黑树，提高了查找的性能，但每次插入新的数据，都得维护红黑树的结构，复杂度为O(logn)。这样算是对查找和插入元素时性能的一个权衡，毕竟存起来就是用来查的</li>
</ul>
<p>此是本人个人愚见，各位dalao如果有其他更有力度的答案，欢迎在评论区答复 （^_^）</p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>部署云服务器</title>
    <url>/2020/01/16/%E9%83%A8%E7%BD%B2%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<hr>
## 本文部署环境

<ul>
<li>阿里云</li>
<li>服务器系统：CentOS7</li>
</ul>
<h2 id="1、购买一个云服务器"><a href="#1、购买一个云服务器" class="headerlink" title="1、购买一个云服务器"></a>1、购买一个云服务器</h2><blockquote>
<p>我自己使用的是阿里云，其他服务器的操作也都是类似的</p>
</blockquote>
<ul>
<li><a href="http://aliyun.com/" target="_blank" rel="noopener">阿里云官网地址</a></li>
<li><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云官网地址</a></li>
<li><a href="https://activity.huaweicloud.com/promotion/index.html" target="_blank" rel="noopener">华为云官网地址</a></li>
</ul>
<h3 id="试用套餐"><a href="#试用套餐" class="headerlink" title="试用套餐"></a>试用套餐</h3><p>如果你是学生或者新注册用户，一般可以使用学生优惠或着有新用户的免费试用，用来学习部署云服务器最为合适。</p>
<p><a href="https://free.aliyun.com/ntms/free/personal.html?handle=true" target="_blank" rel="noopener">阿里云免费试用套餐</a></p>
<h3 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h3><ol>
<li><p>服务器的地域都可以，我本人选的华南。</p>
</li>
<li><p>镜像版本<br> 不论是CentOS还是Ubuntu，只要是Linux的版本都行，就是不建议Window Sever<br> <img src="https://img-blog.csdnimg.cn/20190709150102315.png" alt="选择镜像版本"></p>
<hr>

</li>
</ol>
<h2 id="2、去控制台查看服务器状态"><a href="#2、去控制台查看服务器状态" class="headerlink" title="2、去控制台查看服务器状态"></a>2、去控制台查看服务器状态</h2><p><img src="https://img-blog.csdnimg.cn/20190709143703940.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="首页进入控制台"><br><img src="https://img-blog.csdnimg.cn/20190709143821756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="查看云服务器ECS"></p>
<p><img src="https://img-blog.csdnimg.cn/20190709160537605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="查看服务器"><br>如果没有实例的话，需要自己去手动创建（购买）：<br><img src="https://img-blog.csdnimg.cn/20190709151051921.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>

<h2 id="3、设置安全组"><a href="#3、设置安全组" class="headerlink" title="3、设置安全组"></a>3、设置安全组</h2><p>所谓的安全组，是指服务器开放什么端口，默认只开放22和3389端口。<br>其中，入方向指外网访问服务器的端口，出方向指服务器对外网进行访问的端口。<br><img src="https://img-blog.csdnimg.cn/201907091603536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>配置安全组<br><img src="https://img-blog.csdnimg.cn/20190709154057327.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="点击配置规则"><br>在入方向点击添加安全组规则，<br><img src="https://img-blog.csdnimg.cn/20190709154238376.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190709154850515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安全组配置完成后，需要对具体的实例导入刚刚配置好的安全组规则：</p>
<p><img src="https://img-blog.csdnimg.cn/20190709160239768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>重置密码<br><img src="https://img-blog.csdnimg.cn/201907091602016.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<hr>

<h2 id="4、下载操作工具"><a href="#4、下载操作工具" class="headerlink" title="4、下载操作工具"></a>4、下载操作工具</h2><p>工具：<br>MobaXterm：<a href="https://mobaxterm.mobatek.net/download.html" target="_blank" rel="noopener">官网下载</a><br>Navicat：<a href="https://pan.baidu.com/s/1CmsVRsbuGRbdvF4zHm5qoQ" target="_blank" rel="noopener">百度云（附激活码）</a></p>
<h3 id="1、连接登录："><a href="#1、连接登录：" class="headerlink" title="1、连接登录："></a>1、连接登录：</h3><p><img src="https://img-blog.csdnimg.cn/20190709161601305.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h3 id="2、连接成功效果"><a href="#2、连接成功效果" class="headerlink" title="2、连接成功效果"></a>2、连接成功效果</h3><p><img src="https://img-blog.csdnimg.cn/20190709155925338.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>之后服务器就部署好了，之后只需要给服务器配置好对应的开发环境配置（如Java开发环境、Tomcat等），便可以耍起来啦~，之后会拿出些时间努力写一篇将Web服务部署到云服务器上的、比较详尽的文章。</p>
]]></content>
      <tags>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>【面经】计算机网络</title>
    <url>/2020/01/16/%E3%80%90%E9%9D%A2%E7%BB%8F%E3%80%91%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>[toc]</p>
<hr>

<h2 id="一、三次握手和四次挥手"><a href="#一、三次握手和四次挥手" class="headerlink" title="一、三次握手和四次挥手"></a>一、三次握手和四次挥手</h2><h3 id="（一）、三次握手（建立连接）"><a href="#（一）、三次握手（建立连接）" class="headerlink" title="（一）、三次握手（建立连接）"></a>（一）、三次握手（建立连接）</h3><ol>
<li><p>第一次握手：（Client：我要和你建立连接）</p>
<p>客户端Client将标志位SYN置为1，Seq=J（随机产生），并将数据包发送给服务器端Server，客户端进入SYN_SENT状态，等待Server确认</p>
</li>
<li><p>第二次握手：（Server：你真的要和我建立连接吗？）</p>
<p>Server端收到数据包，由SYN=1可知Client请求建立连接，Server将标志位SYN和确认位置为1，ack=J+1，并置seq=K（随机产生），并将该数据包发送给Client以确认连接请求，Server端进入SYN_RCVD状态。</p>
</li>
<li><p>第三次握手：（Client：我真的要和你建立连接。OK！）</p>
<p>Client端收到确认后，检查ack是否为J+1，确认位是否为1；如果是则将标志位ACK置为1，ack=K+1，之后将该数据包发送给Server端。Server端检查ack是否为K+1，确认位ACK是否为1，正确则连接建立成功，Client和Server两端都进入ESTABLISHED状态，完成三次握手，随后Client和Server之间可以开始传输数据了。</p>
</li>
</ol>
<h3 id="（二）、四次挥手（断开连接）"><a href="#（二）、四次挥手（断开连接）" class="headerlink" title="（二）、四次挥手（断开连接）"></a>（二）、四次挥手（断开连接）</h3><ol>
<li><p>第一次挥手：（Client：我要和你断开连接）</p>
<p>Client端发送一个FIN（finish，FIN占用一个序号），<strong>用于关闭Client到Server端的数据传送</strong>，Client进入FIN_WAIT_1状态。</p>
</li>
<li><p>第二次挥手：（Server：好吧，断吧）</p>
<p>Server端收到FIN后，发送一个ACK给Client端，确认序号ack为FIN序号+1，Server端进入CLOSE_WAIT状态，此时TCP连接处于半关闭状态（客户端已经没有数据发送给服务端，但服务端如果有数据要发送，客户端还是要接收的）。</p>
</li>
<li><p>第三次挥手：（Server：我也要和你断开连接）</p>
<p>Server端发送一个FIN，<strong>用于关闭Server和Client的数据传送</strong>，Server进入LAST_ACK状态。</p>
</li>
<li><p>第四次挥手：（Client：好吧，断吧）</p>
<p>Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server端，ack为FIN序号+1，Server进入CLOSED状态，至此四次挥手结束，完成断开连接。</p>
</li>
</ol>
<hr>

<h2 id="二、为什么TCP连接需要三次握手，两次不可以吗？"><a href="#二、为什么TCP连接需要三次握手，两次不可以吗？" class="headerlink" title="二、为什么TCP连接需要三次握手，两次不可以吗？"></a>二、为什么TCP连接需要三次握手，两次不可以吗？</h2><pre><code>**防止已失效的链接请求报文突然又送到了服务端Server**，因而产生错误，使服务器一直等待建立链接，浪费服务器端的资源。</code></pre><p>　客户端发出的连接请求报文并未丢失，而是在某个网络节点长时间滞留了，以致延误到链接释放以后的某个时间才到达Server。这是，Server误以为这是Client发出的一个新的链接请求，于是就向客户端发送确认数据包，同意建立链接。</p>
<p>若不采用“三次握手”，那么只要Server发出确认数据包，新的链接就建立了。由于client此时并未发出建立链接的请求，所以其不会理睬Server的确认，也不与Server通信；而这时Server一直在等待Client的请求，这样Server就白白浪费了一定的资源。若采用“三次握手”，在这种情况下，由于Server端没有收到来自客户端的确认，则就会知道Client并没有要求建立请求，就不会建立链接。</p>
<hr>

<h2 id="三、保证TCP连接的可靠性"><a href="#三、保证TCP连接的可靠性" class="headerlink" title="三、保证TCP连接的可靠性"></a>三、保证TCP连接的可靠性</h2><pre><code>TCP协议提供一种面向连接的、可靠的字节流服务。面向连接意味着：客户端Client与服务器端Server之间在传输数据之前必须先建立一个TCP连接。字节流服务是指两个应用程序之间通过TCP连接交换８ｂｉｔ字节构成的字节流，而TCP不在字节流中插入记录标识符。</code></pre><p>TCP通过以下方式保证传输的可靠性：</p>
<p>１.　数据包校验</p>
<pre><code>目的是检测数据在传输过程中的任何变化，若校验出包有错，则对其报文段并且不给出响应，这时TCP发送数据段超时后会重发数据。</code></pre><p>２.　对失序数据包重排序</p>
<pre><code>IP数据包的到达可能是失序的，而TCP报文段是作为IP数据报来传输的，因此TCP报文段的到达也可能是失序的。因此TCP会对失序数据进行重新排序，然后再交给应用层。</code></pre><p>３.　丢弃重复数据</p>
<pre><code>对于重复数据，能够丢弃重复数据。</code></pre><p>４.　应答机制</p>
<pre><code>当TCP收到发自TCP连接另一端的数据，它将发送一个确认。（这个确认并不是立即发送的，通常会推迟几分之一秒）</code></pre><p>５.　超时重传</p>
<pre><code>当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</code></pre><p>６.　流量控制</p>
<pre><code>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据，这可以防止较快主机致使较慢主机的缓冲区溢出，这便是流量控制。TCP使用的流量控制协议为大小可变的滑动窗口协议。</code></pre><hr>

<h2 id="四、DDos攻击"><a href="#四、DDos攻击" class="headerlink" title="四、ＤＤｏｓ攻击"></a>四、ＤＤｏｓ攻击</h2><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><ol>
<li>Client端向Server端发送请求连接数据包</li>
<li>Server端向Client端发送确认数据包</li>
<li>Client端并没有向Server端发送确认数据包，服务器一直等待来自客户端的确认</li>
</ol>
<h3 id="DDos的预防"><a href="#DDos的预防" class="headerlink" title="DDos的预防"></a>DDos的预防</h3><blockquote>
<p>DDos无法彻底地根治，除非不使用TCP协议</p>
</blockquote>
<ul>
<li>限制同时打开SYN半连接数目</li>
<li>缩短SYN半连接的TIME OUT超时时间</li>
<li>关闭不必要的服务</li>
</ul>
<hr>

<h2 id="五、TCP和UDP的区别"><a href="#五、TCP和UDP的区别" class="headerlink" title="五、TCP和UDP的区别"></a>五、TCP和UDP的区别</h2><p>TCP (Transmission Control Protocol)和UDP(User Datagram Protocol)协议都属于传输层协议，它们之间的区别包括：</p>
<ul>
<li>TCP是面向连接的，UDP是无连接的；</li>
<li>TCP是可靠的，UDP是不可靠的；</li>
<li>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式；</li>
<li>TCP是面向字节流的，UDP是面向报文的；</li>
<li>TCP有拥塞控制机制，UDP没有拥塞控制机制，适合媒体的通信</li>
<li>TCP首部开销（20个字节）比UDP的首部开销（８个字节）要大。</li>
</ul>
<hr>

<h2 id="六、TCP的拥塞控制"><a href="#六、TCP的拥塞控制" class="headerlink" title="六、TCP的拥塞控制"></a>六、TCP的拥塞控制</h2><pre><code>在某段时间，对网络中某一个资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，这种情况就叫做拥塞。</code></pre><blockquote>
<p>网络资源：计算机网络中的带宽、交换节点中的缓存以及处理机等。</p>
</blockquote>
<pre><code>拥塞控制便是防止过多的数据注入到网络中，避免网络中的路由器或链路过载。

拥塞控制与流量控制不同。拥塞控制是网络链路全局性的控制过程，而流量控制是指点对点通信量的控制。</code></pre><h3 id="拥塞控制的四种方法"><a href="#拥塞控制的四种方法" class="headerlink" title="拥塞控制的四种方法"></a>拥塞控制的四种方法</h3><ol>
<li><p>慢启动（慢开始）：</p>
<pre><code>一开始不发送大量的数据，从１开始以２倍规律增大探测网络的拥塞程度，即从小到大逐渐增加拥塞窗口的大小。</code></pre></li>
<li><p>拥塞避免：</p>
<pre><code>拥塞避免算法是让拥塞窗口缓慢增大，每经过一个RTT往返时间就将发送方的拥塞窗口加1（慢开始门限ssthresh也会随着增加），使拥塞窗口按线性规律缓慢增加。</code></pre></li>
<li><p>快重传：</p>
<pre><code>接收方在收到一个失序的报文段后立即发出对上个接收到的报文的重复确认，使发送方及早发现有报文段没有到达对方。

   在快重传算法中，发送方只要连续收到三个重复确认就应该立即发送对方尚未收到的报文段，而不必接续等待设置的重传计时器时间到期。</code></pre><p><img src="https://img-blog.csdnimg.cn/2019072300000268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<h5><center>快重传</center></h5></li>
<li><p>快恢复：</p>
<pre><code>快恢复算法与快重传配合使用。当发送方收到三个重复确认时，将慢开始门限ssthresh门限减半（称“乘法减小”），cwnd也设为与ssthresh一般大小，然后执行拥塞避免算法。</code></pre></li>
</ol>
<hr>

<h2 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h2><p>OSI模型从低到高有：</p>
<ul>
<li>物理层：<pre><code>物理层规定了激活、维持、关闭通信端点之间的机械特性、电气特性、功能特性、过程特性。该层为上层协议提供了一个传输数据的物理媒体。
在物理层，数据的单位为**比特（bit）**，属于物理层定义的典型规范代表包括：EIA／TIA　RS－２３２，EIA／TIA　RS－４４９，RJ－４５等等。</code></pre></li>
<li>数据链路层<pre><code>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址，数据封装成帧，流量控制，数据检错、重发等。
数据链路层协议的代表：SDLC、ＨＤＬＣ、PPP、STP、帧中继等。在这一层的数据称为帧（frame）</code></pre></li>
<li>网络层<pre><code>网络层负责对子网间的数据包进行路由选择。网络层还有拥塞控制，网际互连等功能。
网络层协议的代表有：IP、IPX、RIP、OSPF等；在这一层的数据称为数据包（package）。</code></pre></li>
<li>传输层<pre><code>传输层是第一个端到端（即主机到主机）的层次。传输层负责将上层数据分段并提供端到端的、可靠或不可靠的传输。此外传输层还要处理端到端的差错控制和流量控制问题。
传输层协议的代表：TCP、UDP、SPX等。在这一层的数据的单位称为数据段（segment）。</code></pre></li>
<li>会话层<pre><code>会话层管理主机之间的会话进程，即负责建立、管理、终止进程之间的会话。此外，会话层利用在数据中插入校检点来实现数据的同步。</code></pre></li>
<li>表示层<pre><code>表示层对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机的应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。</code></pre></li>
<li>应用层<pre><code>应用层为操作系统或网络应用程序提供访问网络服务的接口等。应用层协议的代表包括：Telnet(23/tcp)、FTP（21/tcp）、SMTP（２５/tcp）、HTTP（80/tcp）、DNS（５３/tcp或udp）、SNMP(161/udp)等。</code></pre></li>
</ul>
<blockquote>
<p>待更新……</p>
</blockquote>
]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2020/01/16/Java/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h1><pre><code>JMM全称Java Memory Model 。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。

JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</code></pre><h2 id="一-、JMM定义"><a href="#一-、JMM定义" class="headerlink" title="(一)、JMM定义"></a>(一)、JMM定义</h2><pre><code>Java内存模型（Java Memory Model ,JMM），一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。其目的是解决由于多线程通过共享内存进行通信时，存在的**原子性**、**可见性**（缓存一致性）以及**有序性**问题。</code></pre><br>

<h3 id="原子性问题"><a href="#原子性问题" class="headerlink" title="原子性问题"></a>原子性问题</h3><pre><code>线程是CPU调度的基本单位。

CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</code></pre><br>

<h3 id="可见性问题（缓存一致性）"><a href="#可见性问题（缓存一致性）" class="headerlink" title="可见性问题（缓存一致性）"></a>可见性问题（缓存一致性）</h3><pre><code>在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现**多个线程同时写各自的缓存**的情况，而各自的cache之间的数据就有可能不同。

在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</code></pre><br>
### 有序性问题

<pre><code>除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是有序性问题。
为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。

针对上面的这些问题，不同的操作系统都有不同的解决方案，而Java语言为了屏蔽掉底层的差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</code></pre><p><img src="https://img-blog.csdnimg.cn/20190712024138117.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="Java内存模型"><h5><center>Java内存模型</center></h5><br><br></p>
<hr>

<h2 id="（二）、JMM实现"><a href="#（二）、JMM实现" class="headerlink" title="（二）、JMM实现"></a>（二）、JMM实现</h2><pre><code>在Java中提供了一系列和并发处理相关的关键字，比如 _volatile_ 、_synchronized_、_final_、_concurren_ 包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。

在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。

那么，在Java中，是分别使用什么方式来保证原子性、可见性和有序性呢？</code></pre><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><pre><code>在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit，这两个字节码，在Java中对应的关键字就是synchronized。

因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</code></pre><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><pre><code>Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。

Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</code></pre><blockquote>
<p> 除了volatile，Java中的synchronized和final两个关键字也可以实现可见性，只不过实现方式不同。</p>
</blockquote>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><pre><code>在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</code></pre><ul>
<li><p>volatile关键字会禁止指令重排。</p>
</li>
<li><p>synchronized关键字保证同一时刻只允许一条线程操作。</p>
<p>  在简单介绍完Java并发编程中解决原子性、可见性以及有序性可以使用的关键字后，这个synchronized关键字似乎在每个地方都有它，它可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p>
<p>但是<strong>synchronized是比较影响性能的</strong>，虽然编译器提供了很多锁优化技术，也不建议过度使用。</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis安装配置及数据类型</title>
    <url>/2020/01/16/Redis%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>[toc]</p>
<p>Redis，一个开源的使用ANSI C语言编写、支持网络、可基于内存亦可以持久化的日志型、Key-Value数据库，并提供多种语言的API；</p>
<blockquote>
<p>Redis像是一个HashMap，但它不在JVM中运行，而是以一个独立进程的形式运行。</p>
</blockquote>
<pre><code>数据的存取速度比数据库（Mysql）快，一般会被当作缓存使用，所以常用的数据可以考虑放在这里以**提高性能**。</code></pre><h2 id="Redis安装"><a href="#Redis安装" class="headerlink" title="Redis安装"></a>Redis安装</h2><h3 id="Window安装"><a href="#Window安装" class="headerlink" title="Window安装"></a>Window安装</h3><p><a href="https://github.com/dmajkic/redis/downloads" target="_blank" rel="noopener">window安装地址</a></p>
<p>下载到的Redis支持32bit和64bit。根据自己实际情况选择，将64bit的内容cp到自定义盘符安装目录取名redis。 如 G:\redis。<br>1、打开运行根目录下的 <strong>redis-server.exe</strong> ，运行窗口保持打开状态，不要关了。</p>
<blockquote>
<p>想方便的话，可以将redis的路径加入到系统的环境变量之中，就省得输路径了</p>
<p><img src="https://img-blog.csdnimg.cn/20190803005923736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>2、再打开目录下的<strong>redis-cli.exe</strong>，或者执行命令： redis-cli.exe -h 127.0.0.1 -p 6379<br><img src="https://img-blog.csdnimg.cn/20190803010150494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
</blockquote>
<h2 id="Redis配置"><a href="#Redis配置" class="headerlink" title="Redis配置"></a>Redis配置</h2><p>Redis的配置文件位于Redis安装目录中，文件名为redis.conf</p>
<p>通过CONFIG命令查看和设置配置项</p>
<h3 id="1、查看配置"><a href="#1、查看配置" class="headerlink" title="1、查看配置"></a>1、查看配置</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET CONFIG_SETTING_NAME</span><br></pre></td></tr></table></figure>

<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用符号 * 获取所有配置项</p>
</blockquote>
<h3 id="2、修改配置"><a href="#2、修改配置" class="headerlink" title="2、修改配置"></a>2、修改配置</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET CONFIG_SETTING_NAME NEW_CONFIG_VALUE</span><br></pre></td></tr></table></figure>



<p>例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis 127.0.0.1:6379&gt; CONFIG SET loglevel &quot;notice&quot;</span><br><span class="line">OK</span><br><span class="line">redis 127.0.0.1:6379&gt; CONFIG GET loglevel</span><br><span class="line"></span><br><span class="line">1) &quot;loglevel&quot;</span><br><span class="line">2) &quot;notice&quot;</span><br></pre></td></tr></table></figure>



<h3 id="3、配置项参数说明"><a href="#3、配置项参数说明" class="headerlink" title="3、配置项参数说明"></a>3、配置项参数说明</h3><ol>
<li><p>daemonize：Redis默认不是以守护进程的方式运行，可以通过该配置项修改为yes启用守护进程。</p>
<blockquote>
<p>当redis以守护进程方式运行时，redis默认会把pid写入/var/run/redis.pid文件，可通过pidfile指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pidfile &#x2F;var&#x2F;run&#x2F;redis.pid</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
<li><p>port：指定reids监听端口，默认端口为6379 。</p>
</li>
<li><p>bind：绑定的主机地址，默认127.0.0.1</p>
</li>
<li><p>timeout：客户端闲置多长时间关闭连接，若为0，表示关闭该功能</p>
</li>
<li><p>loglevel：日志记录级别。</p>
<blockquote>
<p>redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose</p>
</blockquote>
</li>
<li><p>databases：设置数据库的数量，默认为0，可使用SELECT &lt;dbid&gt; 命令在连接上指定数据库id</p>
</li>
<li><p>save &lt;seconds&gt;  &lt;changes&gt; ：表示在多长时间内 (以s为单位) 有几次更新操作，将数据同步到数据文件。</p>
<blockquote>
<p>redis中默认配置文件中提供了三个条件：</p>
<ul>
<li>save 900 1</li>
<li>save 300 10</li>
<li>save 60 10000</li>
</ul>
</blockquote>
</li>
<li><p>rdbcompression：指定存储到本地数据库时是否压缩数据，默认为yes。</p>
<blockquote>
<p>redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件大小变得很大</p>
</blockquote>
</li>
<li><p>dbfilename：指定本地数据库文件名，默认值为dump.rdb</p>
</li>
<li><p>dir：指定本地数据库存放目录</p>
</li>
<li><p>slaveof &lt;masterip&gt; &lt;masterport&gt;：</p>
<blockquote>
<p>设置当本机为slav服务时，设置master服务的ip地址以及端口，在redis启动时候，会自动从master进行数据同步</p>
</blockquote>
</li>
<li><p>masterauth &lt;master-password&gt;：当master服务设置了密码保护时候，slav服务连接master的密码。</p>
</li>
<li><p>requirepass foobared：</p>
<p>设置redis连接密码，如果设置了连接密码，客户端在连接redis时候需要通过AUTH &lt;password&gt; 命令提供密码，默认no</p>
</li>
<li><p>maxclients 128：</p>
<pre><code>&gt; 设置同一时间最大客户端连接数，默认无限制。
&gt;
&gt; Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，_如果设置 maxclients 0，表示不作限制_。
&gt;
&gt; 当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</code></pre></li>
<li><p>maxmemory &lt;bytes&gt;：指定Redis最大内存限制</p>
<blockquote>
<p>Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。</p>
<p>Redis新的vm机制，会把Key存放内存，Value会存放在swap区</p>
</blockquote>
</li>
<li><p>appendonly no ：指定是否在每次更新操作后进行日志记录，默认为no</p>
<blockquote>
<p>Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。</p>
<p>因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。</p>
</blockquote>
</li>
<li><p>appendfilename appendonly.aof：指定更新日志文件名，默认为appendonly.aof</p>
</li>
<li><p>appendfsync everysec：指定更新日志条件。</p>
<blockquote>
<p>共有三个可选值：</p>
<ul>
<li>no：表示等操作系统进行数据缓存同步到磁盘（快）</li>
<li>always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）</li>
<li>everysec：表示每秒同步一次（折中，默认）</li>
</ul>
</blockquote>
</li>
<li><p>vm-enabled no：指定是否启用虚拟内存机制，默认值为no</p>
<blockquote>
<p>VM机制将数据进行分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中</p>
</blockquote>
</li>
<li><p>vm-swap-file /tmp/redis.swap：虚拟内存文件路径，默认为/tmp/redis.swap，多个redis实例不可共享。</p>
</li>
<li><p>vm-max-memory 0 ：将所有大于vm-max-memory的数据存入虚拟内存中，默认为0。</p>
<blockquote>
<p>Redis的所有索引数据（即keys）都是存储在内存当中的，无论vm-max-memory设置为何值。</p>
<p>当vm-max-memory设置为0 时，其实便是所有value都存在于磁盘。</p>
</blockquote>
</li>
<li><p>vm-page-size 32：指定swap文件中page的大小，默认为32bytes。</p>
<blockquote>
<p>Redis的swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享。</p>
<p>vm-page-size是要根据存储的 数据大小来设定的,如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值</p>
</blockquote>
</li>
<li><p>vm-pages 134217728：指定swap文件中的page数量，默认大小为 2<sup>27</sup>即134217728。</p>
</li>
<li><p>vm-max-threads 4：设置访问swap文件的线程数，默认值为4。</p>
<blockquote>
<p>最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。</p>
</blockquote>
</li>
<li><p>glueoutputbuf yes：设置在想客户端应答时，是否把较小的包合并为一个包发送，默认为开启。</p>
</li>
<li><p>hash-max-zipmap-entries 64：指定在超过一定的数量时，采用一种特殊的哈希算法</p>
</li>
<li><p>hash-max-zipmap-value 512：指定在最大的元素超过某一临界值时，采用一种特殊的哈希算法</p>
</li>
<li><p>activerehashing yes：指定是否激活重置哈希，默认为yes</p>
</li>
<li><p>include /path/to/local.conf ：指定包含其他的配置文件，可以在同一主机上多个redis实例之间使用同一份配置文件，同时各个实例也拥有自己特定的配置文件。</p>
</li>
</ol>
<h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><p>Redis中有5种数据类型：</p>
<ul>
<li>String    字符串</li>
<li>List        列表</li>
<li>Hash        字典</li>
<li>Set        集合</li>
<li>Sorted Set    有序集合</li>
</ul>
<p>不同的数据类型，有不同的命令方式。</p>
<h3 id="String-相关命令"><a href="#String-相关命令" class="headerlink" title="String 相关命令"></a>String 相关命令</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set (key) (value)			设置key = value</span><br><span class="line">append (key) (value2)		在key对应的value尾部追加value2</span><br><span class="line">get	(key)					获取key对应的value</span><br><span class="line">incr (key)				将key对应的value加1</span><br><span class="line">incrby (key) (value1)		将key对应的value加上value1</span><br><span class="line">ttl (key)					获取key到期的剩余时间</span><br><span class="line">rename (key) (key_new)		对key重命名</span><br><span class="line"></span><br><span class="line">SET key value                   设置key=value</span><br><span class="line">GET key                         或者键key对应的值</span><br><span class="line">GETRANGE key start end          得到字符串的子字符串存放在一个键</span><br><span class="line">GETSET key value                设置键的字符串值，并返回旧值</span><br><span class="line">GETBIT key offset               返回存储在键位值的字符串值的偏移</span><br><span class="line">MGET key1 [key2..]              得到所有的给定键的值</span><br><span class="line">SETBIT key offset value         设置或清除该位在存储在键的字符串值偏移</span><br><span class="line">SETEX key seconds value         键到期时设置值</span><br><span class="line">SETNX key value                 设置键的值，只有当该键不存在</span><br><span class="line">SETRANGE key offset value       覆盖字符串的一部分从指定键的偏移</span><br><span class="line">STRLEN key                      得到存储在键的值的长度</span><br><span class="line">MSET key value [key value...]   设置多个键和多个值</span><br><span class="line">MSETNX key value [key value...] 设置多个键多个值，只有在当没有按键的存在时</span><br><span class="line">PSETEX key milliseconds value   设置键的毫秒值和到期时间</span><br><span class="line">INCR key                        增加键的整数值一次</span><br><span class="line">INCRBY key increment            由给定的数量递增键的整数值</span><br><span class="line">INCRBYFLOAT key increment       由给定的数量递增键的浮点值</span><br><span class="line">DECR key                        递减键一次的整数值</span><br><span class="line">DECRBY key decrement            由给定数目递减键的整数值</span><br><span class="line">APPEND key value                追加值到一个键</span><br><span class="line">DEL key                         如果存在删除键</span><br><span class="line">DUMP key                        返回存储在指定键的值的序列化版本</span><br><span class="line">EXISTS key                      此命令检查该键是否存在</span><br><span class="line">EXPIRE key seconds              指定键的过期时间</span><br><span class="line">EXPIREAT key timestamp          指定的键过期时间。在这里，时间是在Unix时间戳格式</span><br><span class="line">PEXPIRE key milliseconds        设置键以毫秒为单位到期</span><br><span class="line">PEXPIREAT key milliseconds-timestamp        设置键在Unix时间戳指定为毫秒到期</span><br><span class="line">KEYS pattern                    查找与指定模式匹配的所有键</span><br><span class="line">MOVE key db                     移动键到另一个数据库</span><br><span class="line">PERSIST key                     移除过期的键</span><br><span class="line">PTTL key                        以毫秒为单位获取剩余时间的到期键。</span><br><span class="line">TTL key                         获取键到期的剩余时间。</span><br><span class="line">RANDOMKEY                       从Redis返回随机键</span><br><span class="line">RENAME key newkey               更改键的名称</span><br><span class="line">RENAMENX key newkey             重命名键，如果新的键不存在</span><br><span class="line">TYPE key                        返回存储在键的数据类型的值。</span><br></pre></td></tr></table></figure>

<h3 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lpush (listkey) (value)			给listkey列表添加(一个或多个)元素（在前面添加）</span><br><span class="line">rpush (listkey) (value)			给listkey列表添加(一个或多个)元素(在后面添加)</span><br><span class="line">llen (listkey)					获取listkey的长度</span><br><span class="line">lrange (listkey) (start) (end)	从start位置至end位置获取其中的元素</span><br><span class="line"></span><br><span class="line">BLPOP key1 [key2 ] timeout 取出并获取列表中的第一个元素，或阻塞，直到有可用</span><br><span class="line">BRPOP key1 [key2 ] timeout 取出并获取列表中的最后一个元素，或阻塞，直到有可用</span><br><span class="line">BRPOPLPUSH source destination timeout 从列表中弹出一个值，它推到另一个列表并返回它;或阻塞，直到有可用</span><br><span class="line">LINDEX key index 从一个列表其索引获取对应的元素</span><br><span class="line">LINSERT key BEFORE|AFTER pivot value 在列表中的其他元素之后或之前插入一个元素</span><br><span class="line">LLEN key 获取列表的长度</span><br><span class="line">LPOP key 获取并取出列表中的第一个元素</span><br><span class="line">LPUSH key value1 [value2] 在前面加上一个或多个值的列表</span><br><span class="line">LPUSHX key value 在前面加上一个值列表，仅当列表中存在</span><br><span class="line">LRANGE key start stop 从一个列表获取各种元素</span><br><span class="line">LREM key count value 从列表中删除元素</span><br><span class="line">LSET key index value 在列表中的索引设置一个元素的值</span><br><span class="line">LTRIM key start stop 修剪列表到指定的范围内</span><br><span class="line">RPOP key 取出并获取列表中的最后一个元素</span><br><span class="line">RPOPLPUSH source destination 删除最后一个元素的列表，将其附加到另一个列表并返回它</span><br><span class="line">RPUSH key value1 [value2] 添加一个或多个值到列表</span><br><span class="line">RPUSHX key value 添加一个值列表，仅当列表中存在</span><br></pre></td></tr></table></figure>



<h3 id="Hash字典，哈希表"><a href="#Hash字典，哈希表" class="headerlink" title="Hash字典，哈希表"></a>Hash字典，哈希表</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hset person (key) (value)		设置person哈希表中的key键对应值为value</span><br><span class="line">hgetall person					显示person哈希表中所有的key和value</span><br><span class="line">hkeys person					显示person哈希表中所有的keys</span><br><span class="line">hvals person					</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HDEL key field[field...] 删除对象的一个或几个属性域，不存在的属性将被忽略</span><br><span class="line">HEXISTS key field 查看对象是否存在该属性域</span><br><span class="line">HGET key field 获取对象中该field属性域的值</span><br><span class="line">HGETALL key 获取对象的所有属性域和值</span><br><span class="line">HINCRBY key field value 将该对象中指定域的值增加给定的value，原子自增操作，只能是integer的属性值可以使用</span><br><span class="line">HINCRBYFLOAT key field increment 将该对象中指定域的值增加给定的浮点数</span><br><span class="line">HKEYS key 获取对象的所有属性字段</span><br><span class="line">HVALS key 获取对象的所有属性值</span><br><span class="line">HLEN key 获取对象的所有属性字段的总数</span><br><span class="line">HMGET key field[field...] 获取对象的一个或多个指定字段的值</span><br><span class="line">HSET key field value 设置对象指定字段的值</span><br><span class="line">HMSET key field value [field value ...] 同时设置对象中一个或多个字段的值</span><br><span class="line">HSETNX key field value 只在对象不存在指定的字段时才设置字段的值</span><br><span class="line">HSTRLEN key field 返回对象指定field的value的字符串长度，如果该对象或者field不存在，返回0.</span><br><span class="line">HSCAN key cursor [MATCH pattern] [COUNT count] 类似SCAN命令</span><br></pre></td></tr></table></figure>



<h3 id="Set集合"><a href="#Set集合" class="headerlink" title="Set集合"></a>Set集合</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">SADD key member [member ...] 	添加一个或者多个元素到集合(set)里</span><br><span class="line">SCARD key 						获取集合里面的元素数量</span><br><span class="line">SDIFF key [key ...] 			获得队列不存在的元素</span><br><span class="line">SDIFFSTORE destination key [key ...] 获得队列不存在的元素，并存储在一个关键的结果集</span><br><span class="line">SINTER key [key ...] 			获得两个集合的交集</span><br><span class="line">SINTERSTORE destination key [key ...] 获得两个集合的交集，并存储在一个集合中</span><br><span class="line">SISMEMBER key member 			确定一个给定的值是一个集合的成员</span><br><span class="line">SMEMBERS key 					获取集合里面的所有key</span><br><span class="line">SMOVE source destination member 移动集合里面的一个key到另一个集合</span><br><span class="line">SPOP key [count] 				获取并删除一个集合里面的元素</span><br><span class="line">SRANDMEMBER key [count] 		从集合里面随机获取一个元素</span><br><span class="line">SREM key member [member ...] 	从集合里删除一个或多个元素，不存在的元素会被忽略</span><br><span class="line">SUNION key [key ...] 			添加多个set元素</span><br><span class="line">SUNIONSTORE destination key [key ...] 合并set元素，并将结果存入新的set里面</span><br><span class="line">SSCAN key cursor [MATCH pattern] [COUNT count] 迭代set里面的元素</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-Set有序集合"><a href="#Sorted-Set有序集合" class="headerlink" title="Sorted Set有序集合"></a>Sorted Set有序集合</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">ZADD key score1 member1 [score2 member2] </span><br><span class="line">							添加一个或多个成员到有序集合，或者如果它已经存在更新其分数</span><br><span class="line">ZCARD key 					得到的有序集合成员的数量</span><br><span class="line">ZCOUNT key min max 			计算一个有序集合成员与给定值范围内的分数</span><br><span class="line">ZINCRBY key increment member 在有序集合增加成员的分数</span><br><span class="line">ZINTERSTORE destination numkeys key [key ...] </span><br><span class="line">							多重交叉排序集合，并存储生成一个新的键有序集合。</span><br><span class="line">ZLEXCOUNT key min max 		计算一个给定的字典范围之间的有序集合成员的数量</span><br><span class="line">ZRANGE key start stop [WITHSCORES] 由索引返回一个成员范围的有序集合（从低到高）</span><br><span class="line">ZRANGEBYLEX key min max [LIMIT offset count]返回一个成员范围的有序集合（由字典范围）</span><br><span class="line">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT] </span><br><span class="line">							返回有序集key中，所有 score 值介于 min 和 max 之间(包括等于 min 或 max )的成员，有序集成员按 score 值递增(从小到大)次序排列</span><br><span class="line">ZRANK key member 			确定成员的索引中有序集合</span><br><span class="line">ZREM key member [member ...] 从有序集合中删除一个或多个成员，不存在的成员将被忽略</span><br><span class="line">ZREMRANGEBYLEX key min max 	删除所有成员在给定的字典范围之间的有序集合</span><br><span class="line">ZREMRANGEBYRANK key start stop 在给定的索引之内删除所有成员的有序集合</span><br><span class="line">ZREMRANGEBYSCORE key min max 在给定的分数之内删除所有成员的有序集合</span><br><span class="line">ZREVRANGE key start stop [WITHSCORES] </span><br><span class="line">							返回一个成员范围的有序集合，通过索引，以分数排序，从高分到低分</span><br><span class="line">ZREVRANGEBYSCORE key max min [WITHSCORES] </span><br><span class="line">							返回一个成员范围的有序集合，以socre排序从高到低</span><br><span class="line">ZREVRANK key member 		确定一个有序集合成员的索引，以分数排序，从高分到低分</span><br><span class="line">ZSCORE key member 			获取给定成员相关联的分数在一个有序集合</span><br><span class="line">ZUNIONSTORE destination numkeys key [key ...] </span><br><span class="line">							添加多个集排序，所得排序集合存储在一个新的键</span><br><span class="line">ZSCAN key cursor [MATCH pattern] [COUNT count] 增量迭代排序元素集和相关的分数</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>http各个版本的区别</title>
    <url>/2020/01/16/http%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="http1-0、1-1和2-0的区别"><a href="#http1-0、1-1和2-0的区别" class="headerlink" title="http1.0、1.1和2.0的区别"></a>http1.0、1.1和2.0的区别</h1><h2 id="一、1-0与1-1"><a href="#一、1-0与1-1" class="headerlink" title="一、1.0与1.1"></a>一、1.0与1.1</h2><h3 id="1、缓存处理"><a href="#1、缓存处理" class="headerlink" title="1、缓存处理"></a>1、缓存处理</h3><ul>
<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，</li>
<li>HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ul>
<h3 id="2、带宽优化和网络连接的使用"><a href="#2、带宽优化和网络连接的使用" class="headerlink" title="2、带宽优化和网络连接的使用"></a>2、带宽优化和网络连接的使用</h3><ul>
<li>HTTP1.0中，存在一些<strong>浪费带宽</strong>的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，</li>
<li>HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</li>
</ul>
<h3 id="3、错误通知的管理"><a href="#3、错误通知的管理" class="headerlink" title="3、错误通知的管理"></a>3、错误通知的管理</h3><ul>
<li>在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li>
</ul>
<h3 id="4、Host头处理"><a href="#4、Host头处理" class="headerlink" title="4、Host头处理"></a>4、Host头处理</h3><ul>
<li>在HTTP1.0中认为<strong>每台服务器都绑定一个唯一的IP地址</strong>，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。</li>
<li>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</li>
</ul>
<h3 id="5、长连接"><a href="#5、长连接" class="headerlink" title="5、长连接"></a>5、长连接</h3><ul>
<li>HTTP 1.1支持<strong>长连接（PersistentConnection）</strong>和<strong>请求的流水线（Pipelining）处理</strong>，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。</li>
</ul>
<h2 id="二、1-x-的优化"><a href="#二、1-x-的优化" class="headerlink" title="二、1.x 的优化"></a>二、1.x 的优化</h2><p>2012年google提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：</p>
<ol>
<li><p><strong>降低延迟</strong>，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。</p>
</li>
<li><p><strong>请求优先级</strong>（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。</p>
</li>
<li><p><strong>header压缩</strong>。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。</p>
</li>
<li><p><strong>基于HTTPS的加密协议传输</strong>，大大提高了传输数据的可靠性。</p>
</li>
<li><p><strong>服务端推送</strong>（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。</p>
<blockquote>
<p>SPDY位于HTTP之下，TCP和SSL之上，如此可以在兼容老版本HTTP协议的同时使用已有的SSL功能</p>
</blockquote>
</li>
</ol>
<h2 id="三、HTTP２-０：SPDY升级版"><a href="#三、HTTP２-０：SPDY升级版" class="headerlink" title="三、HTTP２.０：SPDY升级版"></a>三、HTTP２.０：SPDY升级版</h2><p>HTTP2.0也是基于SPDY设计的，但其与SPDY仍有不同之处：</p>
<ul>
<li><p>2.0支持明文http传输，而SPDY强制使用HTTPS；</p>
</li>
<li><p>2.0消息头的压缩算法采用HPACK，而不是SPDY采用的DEFLATE：</p>
<blockquote>
<p>HPACK:<a href="http://http2.github.io/http2-spec/compression.html" target="_blank" rel="noopener">http://http2.github.io/http2-spec/compression.html</a></p>
<p>DEFLATE:<a href="http://zh.wikipedia.org/wiki/DEFLATE" target="_blank" rel="noopener">http://zh.wikipedia.org/wiki/DEFLATE</a></p>
</blockquote>
</li>
</ul>
<h3 id="与1-x相比，2-0的新特性"><a href="#与1-x相比，2-0的新特性" class="headerlink" title="与1.x相比，2.0的新特性"></a>与1.x相比，2.0的新特性</h3><h4 id="1、新的二进制格式"><a href="#1、新的二进制格式" class="headerlink" title="1、新的二进制格式"></a>1、新的二进制格式</h4><p>HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多。</p>
<p>HTTP2.0的协议解析采用二进制格式，与文本不同，二进制格式只认0和1的组合，实现方便且健壮。</p>
<h4 id="2、多路复用（MultiPlexing）"><a href="#2、多路复用（MultiPlexing）" class="headerlink" title="2、多路复用（MultiPlexing）"></a>2、多路复用（MultiPlexing）</h4><p>连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。</p>
<h4 id="3、header压缩"><a href="#3、header压缩" class="headerlink" title="3、header压缩"></a>3、header压缩</h4><p>HTTP1.x的header中带有大量信息，而且每次都要重复发送，而HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。</p>
<h4 id="4、服务端推送（server-push）"><a href="#4、服务端推送（server-push）" class="headerlink" title="4、服务端推送（server push）"></a>4、服务端推送（server push）</h4><p>同SPDY一样，HTTP2.0也具有server push功能。</p>
<h1 id="附：HTTPS和HTTP的一些区别"><a href="#附：HTTPS和HTTP的一些区别" class="headerlink" title="附：HTTPS和HTTP的一些区别"></a>附：HTTPS和HTTP的一些区别</h1><ol>
<li>HTTPS协议需要CA证书（数字证书），一般是需要交费的</li>
<li>HTTP协议运行在TCP上，所有传输的内容都是明文传输，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都是经过加密的。</li>
<li>HTTP和HTTPS使用的是完全不同的连接方式，使用的端口不同，HTTP是80端口，HTTPS是４4３端口；</li>
<li>HTTPS能够有效地防止运营商劫持。</li>
</ol>
]]></content>
      <tags>
        <tag>基础知识</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>在编译器中刷LeetCode</title>
    <url>/2020/01/16/LeetCode/%E5%9C%A8%E7%BC%96%E8%AF%91%E5%99%A8%E4%B8%AD%E5%88%B7LeetCode/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="在Idea中刷LeetCode"><a href="#在Idea中刷LeetCode" class="headerlink" title="在Idea中刷LeetCode"></a>在Idea中刷LeetCode</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>  在IDE中解决LeetCode问题,支持<code>leetcode.com</code>与<code>leetcode-cn.com</code>,满足基本的做题需求。<br>  理论上支持: IntelliJ IDEA  PhpStorm  WebStorm  PyCharm  RubyMine  AppCode  CLion  GoLand  DataGrip  Rider MPS  Android Studio。  </p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><p align="center">
  <img src="https://raw.githubusercontent.com/shuzijun/leetcode-editor/master/doc/leetcode-editor-3.0.gif" alt="demo"/>
</p>  


<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul>
<li><strong>通过插件库安装</strong> <a href="https://plugins.jetbrains.com/plugin/12132-leetcode-editor" target="_blank" rel="noopener">https://plugins.jetbrains.com/plugin/12132-leetcode-editor</a>  </li>
<li><strong>下载文件安装</strong> <a href="https://raw.githubusercontent.com/shuzijun/leetcode-editor/master/doc/leetcode-editor.zip" target="_blank" rel="noopener">https://raw.githubusercontent.com/shuzijun/leetcode-editor/master/doc/leetcode-editor.zip</a>  </li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20190723024842494.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20190723025148329.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>安装后记得重启Idea。</p>
<h3 id="配置-第一次安装需要先配置"><a href="#配置-第一次安装需要先配置" class="headerlink" title="配置(第一次安装需要先配置)"></a>配置(第一次安装需要先配置)</h3><p> <img src="https://img-blog.csdnimg.cn/20190723024706996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><strong>配置路径</strong>: <code>File</code> -&gt; <code>settings</code>-&gt;<code>tools</code>-&gt;<code>leetcode plugin</code>  <ul>
<li><strong><code>URL可选项</code></strong>: <code>leetcode.com</code>与<code>leetcode-cn.com</code>  </li>
<li><strong><code>Code Type</code></strong>: <code>Java</code>,<code>Python</code>,<code>C++</code>,<code>Python3</code>,<code>C</code>,<code>C#</code>,<code>JavaScript</code>,<code>Ruby</code>,<code>Swift</code>,<code>Go</code> ,<code>Scala</code>,<code>Kotlin</code>,<code>Rust</code>,<code>PHP</code>   </li>
<li><strong><code>LoginName</code></strong>: 登录用户名</li>
<li><strong><code>Password</code></strong>: 登录密码  </li>
<li><strong><code>Temp File Path</code></strong>: 临时文件存放目录  </li>
</ul>
</li>
</ul>
<h3 id="打开Leetcode窗口（主窗口右下角的LeetCode图标）"><a href="#打开Leetcode窗口（主窗口右下角的LeetCode图标）" class="headerlink" title="打开Leetcode窗口（主窗口右下角的LeetCode图标）"></a>打开Leetcode窗口（主窗口右下角的LeetCode图标）</h3><p><img src="https://img-blog.csdnimg.cn/20190723025314253.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDg0OTU4OA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<ul>
<li><p><strong>工具栏</strong>:<br>如果账号信息没错的话（默认网络良好），工具栏会有Leetcode题库，就可以刷题了（妙啊~）<br><img src="https://img-blog.csdnimg.cn/20190723025416978.png" alt="在这里插入图片描述"></p>
<ul>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2xvZ2luLnBuZw" alt="login"><strong><code>登录</code></strong>:两个网站的登录帐号不互通，切换网站需配置对应的用户  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2xvZ291dC5wbmc" alt="logout"><strong><code>退出</code></strong>:退出当前账户,如遇到登录错误,尝试先进行退出  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL3JlZnJlc2gucG5n" alt="refresh"><strong><code>刷新</code></strong>:在未登录的情况下也可查看刷新加载题目，但是无法提交  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2ZpbmQucG5n" alt="find"><strong><code>查找</code></strong>:输入内容后回车搜索，再次回车搜索下一个，只会搜索题库节点下  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2NvbGxhcHNlQWxsLnBuZw" alt="collapse"><strong><code>折叠</code></strong>:折叠全部节点.  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2NvbmZpZy5wbmc" alt="config"><strong><code>配置</code></strong>:快捷跳转到配置界面  </li>
<li><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL3NodXppanVuL2xlZXRjb2RlLWVkaXRvci9tYXN0ZXIvZG9jL2NsZWFyLnBuZw" alt="clear"><strong><code>清理</code></strong>:清理配置的缓存目录下的文件，两个网站对应的缓存目录不同，只会清理当前配置的网站下的。部分题目未提交的情况下慎重清理  </li>
</ul>
</li>
<li><p><strong>树</strong>:  </p>
<ul>
<li><strong><code>Problems</code></strong>:全部题目  </li>
<li><strong><code>Difficulty</code></strong>:难度分类  </li>
<li><strong><code>Tags</code></strong>:类型分类  </li>
<li><strong><code>Explore</code></strong>:探索内容,只包含题目,收费内容不支持;部分题目加载有顺序限制   </li>
<li><strong><code>颜色</code></strong>:题目颜色代表题目难度  </li>
<li><strong><code>符号</code></strong>:题目前<code>√</code>与<code>？</code>代表当前题目解答状态,探索下有 <code>$</code> 开头的为付费或者其他情况下无法查看的   </li>
</ul>
</li>
</ul>
<h3 id="菜单"><a href="#菜单" class="headerlink" title="菜单"></a>菜单</h3><p><img src="https://img-blog.csdnimg.cn/20190723025724286.png" alt="在这里插入图片描述"></p>
<ul>
<li><strong>菜单(在题目上右击出现)</strong>:  <ul>
<li><strong><code>open question</code></strong>:打开题目,在题目上双击也可以打开  </li>
<li><strong><code>Submit</code></strong>:提交题目  </li>
<li><strong><code>Submissions</code></strong>:查看提交记录,在弹出的窗口上选择记录查看详情(<code>Show detail</code>)  </li>
<li><strong><code>Run Code</code></strong>:运行代码,默认使用题目的测试用例  </li>
<li><strong><code>Testcase</code></strong>:自定义测试用例  </li>
<li><strong><code>Clear cache</code></strong>:清理当前题目</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>Java重写比较器</title>
    <url>/2020/01/16/Java/Java%E9%87%8D%E5%86%99%E6%AF%94%E8%BE%83%E5%99%A8/</url>
    <content><![CDATA[<h1 id="重写Comparetor"><a href="#重写Comparetor" class="headerlink" title="重写Comparetor"></a>重写Comparetor</h1><h3 id="1、Comparetor简单比较"><a href="#1、Comparetor简单比较" class="headerlink" title="1、Comparetor简单比较"></a>1、Comparetor简单比较</h3><p>Java中的排序默认是升序排序，重写为降序如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">           Interval intemp = <span class="keyword">new</span> Interval(i,ia);</span><br><span class="line">           list.add(intemp);</span><br><span class="line">       &#125;</span><br><span class="line">       Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i1, Integer i2)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span> (i1 &gt; i2) &#123;</span><br><span class="line">                   <span class="keyword">return</span> -<span class="number">1</span>; <span class="comment">//不用交换</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//其他情况交换</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">           System.out.println(list.get(i));</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="2、Comparetor对自定义对象排序"><a href="#2、Comparetor对自定义对象排序" class="headerlink" title="2、Comparetor对自定义对象排序"></a>2、Comparetor对自定义对象排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyComparetor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> ia = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Interval</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Interval</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Interval&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Interval intemp = <span class="keyword">new</span> Interval(i,ia);</span><br><span class="line">            list.add(intemp);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list, <span class="keyword">new</span> Comparator&lt;Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Object o1, Object o2)</span> </span>&#123;</span><br><span class="line">                Interval i1 = (Interval)o1;</span><br><span class="line">                Interval i2 = (Interval)o2;</span><br><span class="line">                <span class="keyword">if</span> (i1.start-i1.end &gt; i2.start-i2.end) &#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            System.out.println(list.get(i).start - list.get(i).end);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Mybatis】resultMap解析</title>
    <url>/2020/01/15/Mybatis%E4%B8%AD%E7%9A%84resultMap%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="ResultMap解析"><a href="#ResultMap解析" class="headerlink" title="ResultMap解析"></a>ResultMap解析</h1><p>在Mybatis中，resultMap节点定义了结果集和结果对象（JavaBean）之间的映射规则。</p>
<p>本文章主要讲述的是resultMap的解析。</p>
<h2 id="相关基础类"><a href="#相关基础类" class="headerlink" title="相关基础类"></a>相关基础类</h2><h3 id="1、ResultMapping：列映射类"><a href="#1、ResultMapping：列映射类" class="headerlink" title="1、ResultMapping：列映射类"></a>1、ResultMapping：列映射类</h3><p>ResultMapping对象记录了结果集中的一列与对应JavaBean中一个属性的映射关系；</p>
<blockquote>
<p>文章参考：</p>
<p> <a href="https://www.cnblogs.com/homejim/p/9833863.html" target="_blank" rel="noopener">列映射类ResultMapping</a> </p>
</blockquote>
<h3 id="2、ResultMap：结果集映射类ResultMap"><a href="#2、ResultMap：结果集映射类ResultMap" class="headerlink" title="2、ResultMap：结果集映射类ResultMap"></a>2、ResultMap：结果集映射类ResultMap</h3><p>ResultMap对应的是结果集中的一个结果集。其基本组成部分中，含有ResultMapping对象。</p>
<blockquote>
<p>文章参考：</p>
<p><a href="https://www.cnblogs.com/homejim/p/9840373.html" target="_blank" rel="noopener">结果集映射类ResultMap</a></p>
</blockquote>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><h3 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h3><p>resultMap是解析Mapper的一个环节，其处于mapper.xml文件下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br></pre></td></tr></table></figure>

<p>解析是可以存在多个的，故 <code>context.evalNodes(&quot;/mapper/resultMap&quot;)</code>返回的是一个List列表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resultMapElements</span><span class="params">(List&lt;XNode&gt; list)</span><span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(XNode resultMapNode:list)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            resultMapElement(resultMapNode);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(IncompleteElementException e)&#123;</span><br><span class="line">            <span class="comment">//ignore,it will be retried</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="resultMapElement函数"><a href="#resultMapElement函数" class="headerlink" title="resultMapElement函数"></a>resultMapElement函数</h3><p>整个过程都是在resultMapElement这个函数中进行的，相关代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> resultMapElement(resultMapNode,Collections,&lt;ResultMapping&gt; emptyList());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 处理&lt;resultMap&gt;节点，将节点解析成ResultMap对象，下面包含有ResultMapping对象组成的列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> resultMapNode resultMap节点</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> additionalResultMappings 另外的ResultMapping列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> ResultMap对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ResultMap <span class="title">resultMapElement</span><span class="params">(XNode resultMapNode,List&lt;ResultMapping&gt; additionalResultMappings)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    ErrorContext.instance().activity(<span class="string">"processing "</span>+resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">//获取Id，默认拼装所有父节点的id或value或property。是一个身份标识，具有唯一性。</span></span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>,resultMapNode.getValueBasedIdentifier());</span><br><span class="line">    <span class="comment">//获取type属性，表示结果集将被映射为type指定类型的对象</span></span><br><span class="line">    String type = resultMapNode.getStringAttribute(<span class="string">"type"</span>,</span><br><span class="line">                                               resultMapNode.getStringAttribute(<span class="string">"ofType"</span>,</span><br><span class="line">                                           resultMapNode.getStringAttribute(<span class="string">"resultType"</span>,</span><br><span class="line">                                         resultMapNode.getStringAttribute(<span class="string">"javaType"</span>))));</span><br><span class="line">    <span class="comment">//获取extends属性，表示结果集的继承</span></span><br><span class="line">    String extend = resultMapNode.getStringAttribute(<span class="string">"extends"</span>);</span><br><span class="line">    <span class="comment">//自动映射属性。列名自动映射为属性</span></span><br><span class="line">    Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">"autoMapping"</span>);</span><br><span class="line">    <span class="comment">//解析type，获取其类型</span></span><br><span class="line">    Class&lt;?&gt; typeClass = resolveClass(type);</span><br><span class="line">    Discriminator discriminator = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//记录解析结果</span></span><br><span class="line">    List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    resultMappings.addAll(additionalResultMappings);</span><br><span class="line">    <span class="comment">//处理子节点</span></span><br><span class="line">    List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">    <span class="keyword">for</span>(XNode resultChild : resultChildren)&#123;</span><br><span class="line">        <span class="comment">//处理constructor节点</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"constructor"</span>.equals(resultChild.getName()))&#123;</span><br><span class="line">            <span class="comment">//解析构造函数元素，其下的每一个子节点产生一个ResultMapping对象</span></span><br><span class="line">            processConstructorElement(resultChild,typeClass,resultMappings);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"discriminator"</span>.equals(resultChild.getName())) &#123;<span class="comment">//处理discriminator节点</span></span><br><span class="line">            discriminator = processDiscriminatorElement(resultChild,typeClass,resultMappings);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;<span class="comment">//处理其余节点</span></span><br><span class="line">            List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"id"</span>.equals(resultChild.getName()))&#123;</span><br><span class="line">                flags.add(ResultFlag.ID);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//创建resultMap对象，并添加到resultMappings中</span></span><br><span class="line">            resultMapping.add(buildResultMappingFromContext(resultChild,typeClass,flags));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 ResultMapResolver 对象， 该对象可以生成 ResultMap 对象</span></span><br><span class="line">    ResultMapResolver resultMapResolver = <span class="keyword">new</span> ResultMapResolver(builderAssistant,id,typeClass,extend, discriminator, resultMappings, autoMapping);</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> resultMapResolver.resolve();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (IncompleteElementException e)&#123;</span><br><span class="line">        <span class="comment">//若无法创建ResultMap对象，则将该结果添加到incompleteResultMaps集合中</span></span><br><span class="line">        configuration.addIncompleteResultMap(resultMapResolver);</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="详细解析"><a href="#详细解析" class="headerlink" title="详细解析"></a>详细解析</h3><ul>
<li><p>获取id</p>
<p>id 对于 resultMap 来说是很重要的， 它是一个身份标识。具有唯一性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取 ID , 默认值会拼装所有父节点的 id 或 value 或 property。</span></span><br><span class="line">    String id = resultMapNode.getStringAttribute(<span class="string">"id"</span>, resultMapNode.getValueBasedIdentifier());</span><br></pre></td></tr></table></figure>

<p>这里涉及到 <code>XNode</code> 对象中的两个函数：getStringAttribute()以及getValueBasedIdentifier()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getStringAttribute</span><span class="params">(String name, String def)</span> </span>&#123;</span><br><span class="line">    String value = attributes.getProperty(name);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> def;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是获取 <code>XNode</code> 对象对应 <code>XML</code> 节点的 <code>name</code> 属性值， 如果该属性不存在， 则返回传入的默认值 def。</p>
<p>而在获取 id 的过程中, 默认值是下面这个函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生成元素节点的基础 id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getValueBasedIdentifier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">  XNode current = <span class="keyword">this</span>;</span><br><span class="line">  <span class="comment">// 当前的节点不为空</span></span><br><span class="line">  <span class="keyword">while</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果节点不等于 this， 则在0之前插入 _ 符号， 因为是不断的获取父节点的， 因此是插在前面</span></span><br><span class="line">    <span class="keyword">if</span> (current != <span class="keyword">this</span>) &#123;</span><br><span class="line">      builder.insert(<span class="number">0</span>, <span class="string">"_"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 id， id不存在则获取value, value不存在则获取 property。</span></span><br><span class="line">    String value = current.getStringAttribute(<span class="string">"id"</span>,</span><br><span class="line">        current.getStringAttribute(<span class="string">"value"</span>,</span><br><span class="line">            current.getStringAttribute(<span class="string">"property"</span>, <span class="keyword">null</span>)));</span><br><span class="line">    <span class="comment">// value 非空， 则将.替换为_， 并将value的值加上 []</span></span><br><span class="line">    <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">      value = value.replace(<span class="string">'.'</span>, <span class="string">'_'</span>);</span><br><span class="line">      builder.insert(<span class="number">0</span>, <span class="string">"]"</span>);</span><br><span class="line">      builder.insert(<span class="number">0</span>,</span><br><span class="line">          value);</span><br><span class="line">      builder.insert(<span class="number">0</span>, <span class="string">"["</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不管 value 是否存在， 前面都添加上节点的名称</span></span><br><span class="line">    builder.insert(<span class="number">0</span>, current.getName());</span><br><span class="line">    <span class="comment">// 获取父节点</span></span><br><span class="line">    current = current.getParent();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> builder.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数是生成元素节点的id, 如果是这样子的 XML。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">employee</span> <span class="attr">id</span>=<span class="string">"$&#123;id_var&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">blah</span> <span class="attr">something</span>=<span class="string">"that"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">first_name</span>&gt;</span>Jim<span class="tag">&lt;/<span class="name">first_name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">last_name</span>&gt;</span>Smith<span class="tag">&lt;/<span class="name">last_name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">birth_date</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">year</span>&gt;</span>1970<span class="tag">&lt;/<span class="name">year</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">month</span>&gt;</span>6<span class="tag">&lt;/<span class="name">month</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">day</span>&gt;</span>15<span class="tag">&lt;/<span class="name">day</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">birth_date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">height</span> <span class="attr">units</span>=<span class="string">"ft"</span>&gt;</span>5.8<span class="tag">&lt;/<span class="name">height</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">weight</span> <span class="attr">units</span>=<span class="string">"lbs"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">weight</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">active</span>&gt;</span>true<span class="tag">&lt;/<span class="name">active</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">employee</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">XNode node = parser.evalNode(<span class="string">"/employee/height"</span>); node.getValueBasedIdentifier();</span><br></pre></td></tr></table></figure>

<p>则， 返回值应该是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">employee[$&#123;id_var&#125;]_height</span><br></pre></td></tr></table></figure>
</li>
<li><p>解析结果集中的类型</p>
<p> 结果集的类型， 对应的是一个 <code>JavaBean</code> 对象。通过反射来获得该类型。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取type， type 不存在则获取 ofType, ofType </span></span><br><span class="line"><span class="comment">// 不存在则获取 resultType, resultType 不存在则获取 javaType</span></span><br><span class="line">String type = resultMapNode.getStringAttribute(<span class="string">"type"</span>,</span><br><span class="line">    resultMapNode.getStringAttribute(<span class="string">"ofType"</span>,</span><br><span class="line">        resultMapNode.getStringAttribute(<span class="string">"resultType"</span>,</span><br><span class="line">            resultMapNode.getStringAttribute(<span class="string">"javaType"</span>))));</span><br><span class="line"><span class="comment">// ... ...</span></span><br><span class="line"><span class="comment">// 获取 type 对应的 Class 对象</span></span><br><span class="line">Class&lt;?&gt; typeClass = resolveClass(type);</span><br></pre></td></tr></table></figure>

<p> 看源码， 有很多个 def 值， 也就是说， 我们在配置结果集的类型的时候都是有优先级的。但是， 这里有一个奇怪的地方， 我源代码版本（3.5.0-SNAPSHOT）的 的属性， 只有 type, 没有 ofType/resultType/javaType。以下为相应的 DTD 约束： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!ELEMENT resultMap (constructor?,id*,result*,association*,collection*, discriminator?)&gt;</span><br><span class="line">&lt;!ATTLIST resultMap</span><br><span class="line">id CDATA #REQUIRED</span><br><span class="line">type CDATA #REQUIRED</span><br><span class="line">extends CDATA #IMPLIED</span><br><span class="line">autoMapping (true|false) #IMPLIED&gt;</span><br></pre></td></tr></table></figure>

<p>这里可能是考虑到对以前版本的兼容性。</p>
</li>
<li><p>获取继承结果集和自动映射</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String extend = resultMapNode.getStringAttribute(<span class="string">"extends"</span>);</span><br><span class="line">   Boolean autoMapping = resultMapNode.getBooleanAttribute(<span class="string">"autoMapping"</span>);</span><br></pre></td></tr></table></figure>

<p>这两个属性在配置XML的时候，显得有些可有可无。</p>
</li>
<li><p>解析</p>
<p>根据类型进行解析，获得resultMappings</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个 resultMappings 的链表</span></span><br><span class="line">   List&lt;ResultMapping&gt; resultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">   <span class="comment">// 将从其他地方传入的additionalResultMappings添加到该链表中</span></span><br><span class="line">   resultMappings.addAll(additionalResultMappings);</span><br><span class="line">   <span class="comment">// 获取子节点</span></span><br><span class="line">   List&lt;XNode&gt; resultChildren = resultMapNode.getChildren();</span><br><span class="line">   <span class="comment">// 遍历解析子节点</span></span><br><span class="line">   <span class="keyword">for</span> (XNode resultChild : resultChildren) &#123;</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">"constructor"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">       <span class="comment">// 解析构造函数元素，其下的没每一个子节点都会生产一个 ResultMapping 对象</span></span><br><span class="line">       processConstructorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">     &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"discriminator"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">       <span class="comment">// 解析 discriminator 节点</span></span><br><span class="line">       discriminator = processDiscriminatorElement(resultChild, typeClass, resultMappings);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 解析其余的节点</span></span><br><span class="line">       List&lt;ResultFlag&gt; flags = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">       <span class="keyword">if</span> (<span class="string">"id"</span>.equals(resultChild.getName())) &#123;</span><br><span class="line">         flags.add(ResultFlag.ID);</span><br><span class="line">       &#125;</span><br><span class="line">       resultMappings.add(buildResultMappingFromContext(resultChild, typeClass, flags));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>除了discriminator节点，其他节点最后都会回到buildResultMappingFromContext方法，该方法为创建ResultMapping对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取一行， 如result等， 取得他们所有的属性， 通过这些属性建立 `ResultMapping` 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> context 对于节点本身</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resultType resultMap 的结果类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> flags flag 属性， 对应 ResultFlag 枚举中的属性。 一般情况下为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回 ResultMapping</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> ResultMapping <span class="title">buildResultMappingFromContext</span><span class="params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultFlag&gt; flags)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String property;</span><br><span class="line">    <span class="comment">// 获取节点的属性， 如果节点是构造函数（只有name属性， 没有property），</span></span><br><span class="line">    <span class="comment">// 则获取的是 name, 否则获取 property</span></span><br><span class="line">    <span class="keyword">if</span> (flags.contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">      property = context.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      property = context.getStringAttribute(<span class="string">"property"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    String nestedSelect = context.getStringAttribute(<span class="string">"select"</span>);</span><br><span class="line">    <span class="comment">// 获取嵌套的结果集</span></span><br><span class="line">    String nestedResultMap = context.getStringAttribute(<span class="string">"resultMap"</span>,</span><br><span class="line">        processNestedResultMappings(context, Collections.&lt;ResultMapping&gt; emptyList()));</span><br><span class="line">    String notNullColumn = context.getStringAttribute(<span class="string">"notNullColumn"</span>);</span><br><span class="line">    String columnPrefix = context.getStringAttribute(<span class="string">"columnPrefix"</span>);</span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    String resultSet = context.getStringAttribute(<span class="string">"resultSet"</span>);</span><br><span class="line">    String foreignColumn = context.getStringAttribute(<span class="string">"foreignColumn"</span>);</span><br><span class="line">    <span class="keyword">boolean</span> lazy = <span class="string">"lazy"</span>.equals(context.getStringAttribute(<span class="string">"fetchType"</span>, configuration.isLazyLoadingEnabled() ? <span class="string">"lazy"</span> : <span class="string">"eager"</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 以上获取各个属性节点</span></span><br><span class="line">    <span class="comment">// 解析 javaType， typeHandler， jdbcType</span></span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">    <span class="comment">// 创建resultMapping对象</span></span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildResultMapping(resultType, property, column, javaTypeClass, jdbcTypeEnum, nestedSelect, nestedResultMap, notNullColumn, columnPrefix, typeHandlerClass, flags, resultSet, foreignColumn, lazy);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>对于discriminator，则处理该元素，并创建鉴别器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理鉴别器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> context 节点</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resultType 结果类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resultMappings 列结果集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 鉴别器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Discriminator <span class="title">processDiscriminatorElement</span><span class="params">(XNode context, Class&lt;?&gt; resultType, List&lt;ResultMapping&gt; resultMappings)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String column = context.getStringAttribute(<span class="string">"column"</span>);</span><br><span class="line">    String javaType = context.getStringAttribute(<span class="string">"javaType"</span>);</span><br><span class="line">    String jdbcType = context.getStringAttribute(<span class="string">"jdbcType"</span>);</span><br><span class="line">    String typeHandler = context.getStringAttribute(<span class="string">"typeHandler"</span>);</span><br><span class="line">    <span class="comment">// 先获取各个属性</span></span><br><span class="line">    <span class="comment">// 取得 javaType 对应的类型</span></span><br><span class="line">    Class&lt;?&gt; javaTypeClass = resolveClass(javaType);</span><br><span class="line">    <span class="comment">// 取得 typeHandler 对应的类型</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    Class&lt;? extends TypeHandler&lt;?&gt;&gt; typeHandlerClass = (Class&lt;? extends TypeHandler&lt;?&gt;&gt;) resolveClass(typeHandler);</span><br><span class="line">    <span class="comment">// 取得 jdbcType 对应的类型</span></span><br><span class="line">    JdbcType jdbcTypeEnum = resolveJdbcType(jdbcType);</span><br><span class="line">    <span class="comment">// 创建 discriminatorMap， 并遍历子节点， 以 value-&gt;resultMap 的方式放入discriminatorMap中</span></span><br><span class="line">    Map&lt;String, String&gt; discriminatorMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (XNode caseChild : context.getChildren()) &#123;</span><br><span class="line">      String value = caseChild.getStringAttribute(<span class="string">"value"</span>);</span><br><span class="line">      String resultMap = caseChild.getStringAttribute(<span class="string">"resultMap"</span>, processNestedResultMappings(caseChild, resultMappings));</span><br><span class="line">      discriminatorMap.put(value, resultMap);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建鉴别器</span></span><br><span class="line">    <span class="keyword">return</span> builderAssistant.buildDiscriminator(resultType, column, javaTypeClass, jdbcTypeEnum, typeHandlerClass, discriminatorMap);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>在鉴别器内部中，也是含有ResultMapping的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Discriminator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ResultMapping resultMapping;</span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; discriminatorMap;</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>创建ResultMap对象</p>
<p>解析各个属性和子节点完毕之后，创建ResultMapResolver对象，通过对象可以生成ResultMap。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建并添加 ResultMap 到 Configuration 对象中</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> id id, 配置了 id 可以提高效率</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> extend 继承</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> discriminator 鉴别器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> resultMappings 列集</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> autoMapping 是否自动映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 返回创建的 ResultMap 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultMap <span class="title">addResultMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      String id,</span></span></span><br><span class="line"><span class="function"><span class="params">      Class&lt;?&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">      String extend,</span></span></span><br><span class="line"><span class="function"><span class="params">      Discriminator discriminator,</span></span></span><br><span class="line"><span class="function"><span class="params">      List&lt;ResultMapping&gt; resultMappings,</span></span></span><br><span class="line"><span class="function"><span class="params">      Boolean autoMapping)</span> </span>&#123;</span><br><span class="line">    id = applyCurrentNamespace(id, <span class="keyword">false</span>);</span><br><span class="line">    extend = applyCurrentNamespace(extend, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (extend != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!configuration.hasResultMap(extend)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteElementException(<span class="string">"Could not find a parent resultmap with id '"</span> + extend + <span class="string">"'"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 从 configuration 中获取继承的结果集</span></span><br><span class="line">      ResultMap resultMap = configuration.getResultMap(extend);</span><br><span class="line">      <span class="comment">// 获取所集成结果集的所有 ResultMapping 集合</span></span><br><span class="line">      List&lt;ResultMapping&gt; extendedResultMappings = <span class="keyword">new</span> ArrayList&lt;&gt;(resultMap.getResultMappings());</span><br><span class="line">      <span class="comment">// 移除需要覆盖的 ResultMapping 集合</span></span><br><span class="line">      extendedResultMappings.removeAll(resultMappings);</span><br><span class="line">      <span class="comment">// 如果该 resultMap 中定义了构造节点， 则移除其父节点的构造器</span></span><br><span class="line">      <span class="keyword">boolean</span> declaresConstructor = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">for</span> (ResultMapping resultMapping : resultMappings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultMapping.getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">          declaresConstructor = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (declaresConstructor) &#123;</span><br><span class="line">        Iterator&lt;ResultMapping&gt; extendedResultMappingsIter = extendedResultMappings.iterator();</span><br><span class="line">        <span class="keyword">while</span> (extendedResultMappingsIter.hasNext()) &#123;</span><br><span class="line">          <span class="keyword">if</span> (extendedResultMappingsIter.next().getFlags().contains(ResultFlag.CONSTRUCTOR)) &#123;</span><br><span class="line">            extendedResultMappingsIter.remove();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 添加需要被继承的 ResultMapping 集合</span></span><br><span class="line">      resultMappings.addAll(extendedResultMappings);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过建造者模式创建 ResultMap 对象</span></span><br><span class="line">    ResultMap resultMap = <span class="keyword">new</span> ResultMap.Builder(configuration, id, type, resultMappings, autoMapping)</span><br><span class="line">        .discriminator(discriminator)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 添加到 Configuration 对象中</span></span><br><span class="line">    configuration.addResultMap(resultMap);</span><br><span class="line">    <span class="keyword">return</span> resultMap;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p><a href="https://mp.weixin.qq.com/s/zL0d4odAeZIqTTeOesXgYA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/zL0d4odAeZIqTTeOesXgYA</a></p>
<h2 id="Github示例代码"><a href="#Github示例代码" class="headerlink" title="Github示例代码"></a>Github示例代码</h2><p> <a href="https://github.com/homejim/mybatis-cn" target="_blank" rel="noopener">https://github.com/homejim/mybatis-cn</a> </p>
]]></content>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>负载均衡算法</title>
    <url>/2020/01/12/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>均衡地将客户端请求分散到各个服务器中</p>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h2 id="最小活跃数"><a href="#最小活跃数" class="headerlink" title="最小活跃数"></a>最小活跃数</h2><h2 id="随机算法"><a href="#随机算法" class="headerlink" title="随机算法"></a>随机算法</h2><p>随机权重考虑</p>
<p>eg：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerIps</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;String&gt; LIST = Arrays.asList(</span><br><span class="line">        <span class="string">"162.168.0.1"</span>,</span><br><span class="line">        <span class="string">"162.168.0.2"</span>,</span><br><span class="line">        <span class="string">"162.168.0.3"</span>,</span><br><span class="line">        <span class="string">"162.168.0.4"</span>,</span><br><span class="line">        <span class="string">"162.168.0.5"</span>,</span><br><span class="line">        <span class="string">"162.168.0.6"</span>,</span><br><span class="line">        <span class="string">"162.168.0.7"</span>,</span><br><span class="line">        <span class="string">"162.168.0.8"</span>,</span><br><span class="line">        <span class="string">"162.168.0.9"</span>,</span><br><span class="line">        <span class="string">"162.168.0.10"</span></span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String,Integer&gt; WEIGHT_LIST = <span class="keyword">new</span> LinkedHashMap&lt;String,Integer&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//权重之和为50</span></span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.1"</span>,<span class="number">1</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.2"</span>,<span class="number">8</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.3"</span>,<span class="number">3</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.4"</span>,<span class="number">6</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.5"</span>,<span class="number">5</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.6"</span>,<span class="number">5</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.7"</span>,<span class="number">4</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.8"</span>,<span class="number">7</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.9"</span>,<span class="number">2</span>);</span><br><span class="line">        WEIGHT_LIST.put(<span class="string">"162.168.0.10"</span>,<span class="number">9</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、普通随机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Random</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        java.util.Random ran = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">        <span class="keyword">int</span> rand = random.nextInt(ServerIps.LIST.size());</span><br><span class="line">        <span class="keyword">return</span> ServerIps.LIST.get(rand);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、权重随机</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandom</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; ips = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(String ip:ServerIps.WEIGHT_LIST.keySet())&#123;</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;weight;i++)&#123;</span><br><span class="line">                ips.add(ip);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        java.util.Random random = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">        <span class="keyword">int</span> randomPos = random.nextInt(ips.size());</span><br><span class="line">        <span class="keyword">return</span> ips.get(randomPos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="区域权重随机"><a href="#区域权重随机" class="headerlink" title="区域权重随机"></a>区域权重随机</h3><p>用<strong>区域范围大小</strong>代表<strong>权重大小</strong>，随机出来的数所落位置的范围代表的数字便是根据权重选出的数字，暂时称为区域权重随机算法吧。</p>
<blockquote>
<p>eg：</p>
<p>有三个服务器ABC，负载均衡的权重如下：</p>
<ul>
<li><p>A：5</p>
</li>
<li><p>B：3</p>
</li>
<li><p>C：2</p>
</li>
</ul>
<p>如果此时客户端发过来一个请求，通过区域权重随机算法分配的思路画图如下：</p>
<p>0_____5___8__10</p>
<p>将三个服务器的权重看成一个长度，权重也大，在坐标轴上占的区域长度也越长，以此实现权重的随机。设随机数为x，则有以下情况：</p>
<ol>
<li>若x∈[0,5)，则请求分配给A服务器；</li>
<li>若x-5∈[0,3)，则请求分配给B服务器；</li>
<li>若x-8∈[0,2)，则请求分配给C服务器。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//区域权重随机算法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRandom2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer weight;ServerIps.WEIGHT_LIST.values())&#123;</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        java.util.Random random = <span class="keyword">new</span> java.util.Random();</span><br><span class="line">        random.nextInt(totalWeight);</span><br><span class="line">        <span class="keyword">for</span>(String ip:ServerIps.WEIGHT_LIST.keySet())&#123;</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;weight)&#123;</span><br><span class="line">                <span class="keyword">return</span> ip;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos - weight;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="轮询算法"><a href="#轮询算法" class="headerlink" title="轮询算法"></a>轮询算法</h2><p>普通的轮询算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoundRobin</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Integer pos = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String ip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">synchronized</span>(pos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(pos &gt;= ServerIps.LIST.size())&#123;</span><br><span class="line">                pos = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ip = ServerIps.LIST.get(pos);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ip;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(getServer());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>权重轮询算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestId</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer num = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getAndIncreatedment</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeightRoundRobinV2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalWeight = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer weight:ServerIps.WEIGHT_LIST.values())&#123;</span><br><span class="line">            totalWeight += weight;</span><br><span class="line">        &#125;</span><br><span class="line">        Integer requestId = RequestId.getAndIncreatedment();</span><br><span class="line">        Integer pos = requestId % totalWeight;</span><br><span class="line">        <span class="keyword">for</span>(String ip : ServerIps.WEIGHT_LIST.keySet())&#123;</span><br><span class="line">            Integer weight = ServerIps.WEIGHT_LIST.get(ip);</span><br><span class="line">            <span class="keyword">if</span>(pos&lt;weight)&#123;</span><br><span class="line">                <span class="keyword">return</span> ip;</span><br><span class="line">            &#125;</span><br><span class="line">            pos = pos - weight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <tags>
        <tag>负载均衡算法</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot企业开发</title>
    <url>/2020/01/09/SpringBoot%E4%BC%81%E4%B8%9A%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<h1 id="SpringBoot企业开发"><a href="#SpringBoot企业开发" class="headerlink" title="SpringBoot企业开发"></a>SpringBoot企业开发</h1><p>本文主要介绍在Spring boot企业开发中一些常用的功能：邮件发送、定时任务、批处理、Swagger2和数据校验等，这些功能都有着非常广泛的使用场景，如用户注册、修改密码、定时备份、接口文档等。除了Swagger2外，其他功能在Springboot中都提供了相关的Starter，简化了开发过程，明显提高了开发效率。</p>
<h2 id="一、邮件发送"><a href="#一、邮件发送" class="headerlink" title="一、邮件发送"></a>一、邮件发送</h2><p>qq邮箱配置验证码：略</p>
<ol>
<li><p>环境搭建</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置application.yml，如邮件服务器的地址、端口（465或587）、用户账号和密码以及默认编码、SSL连接配置等信息（application.properties配置类似）:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">mail:</span></span><br><span class="line">		<span class="attr">host:</span> <span class="string">smtp.qq.com</span></span><br><span class="line">		<span class="attr">port:</span> <span class="number">465</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">xxx@qq.com</span></span><br><span class="line">		<span class="attr">password:</span> <span class="comment">#填写通过邮箱申请到的验证码</span></span><br><span class="line">		<span class="attr">default-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line">		<span class="attr">properties:</span> </span><br><span class="line">			<span class="attr">mail:</span> </span><br><span class="line">				<span class="attr">debug:</span> <span class="literal">true</span></span><br><span class="line">				<span class="attr">smtp:</span> </span><br><span class="line">					<span class="attr">socketFactory:</span></span><br><span class="line">						<span class="attr">class:</span> <span class="string">javax.net.ssl.SSLSocketFactory</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>发送简单邮件</p>
<p>创建MailService封装邮件的发送：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JavaMailSender javaMailSender;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleMail</span><span class="params">(String from,String to,String cc,String subject,String content)</span></span>&#123;</span><br><span class="line">        SimpleMailMessage simpMsg = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">        simpMsg.setFrom(from);</span><br><span class="line">        simpMsg.setTo(to);</span><br><span class="line">        simpMsg.setCc(cc);</span><br><span class="line">        simpMsg.setSubject(subject);</span><br><span class="line">        simpMsg.setText(content);</span><br><span class="line">        javaMailSender.send(simpMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   测试方法：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">Spring</span> <span class="title">BootTest</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SendmailApplicationTests</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    MailService mailService;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSimpleMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        mailService.sendSimpleMail(<span class="string">"#发件人邮箱#"</span>,</span><br><span class="line">                                  <span class="string">"#收件人邮箱#"</span>,</span><br><span class="line">                                  <span class="string">"#抄送邮箱#"</span>,</span><br><span class="line">                                  <span class="string">"#邮件主题#"</span>,</span><br><span class="line">                                  <span class="string">"#邮件内容#"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>发送带有附件的邮件</p>
<p>要发送带有附件的邮件，只需要通过调用Attachment方法即可添加附件，多次调用该方法即可添加多个附件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendAttachFileMail</span><span class="params">(String from,String to,String subject,String content,File file)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        MimeMesage message = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content);</span><br><span class="line">        helper.setAttachment(file.getName(),file);</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MessageingException e)&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送带图片资源的邮件</p>
<p>可以利用FileSystemResource实现这一功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMailWithImg</span><span class="params">(String from,String to,String subject,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String content,String[] srcPath,</span></span></span><br><span class="line"><span class="function"><span class="params">                            String[] resIds)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(srcPath.length != resIds.length)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send Fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        MimeMessage message = javaMailSender.createMimeMessage();</span><br><span class="line">        MimeMessageHelper helper = <span class="keyword">new</span> MimeMessageHelper(message,<span class="keyword">true</span>);</span><br><span class="line">        helper.setFrom(from);</span><br><span class="line">        helper.setTo(to);</span><br><span class="line">        helper.setSubject(subject);</span><br><span class="line">        helper.setText(content,<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;srPath.length;i++)&#123;</span><br><span class="line">            FileSystemResource res = <span class="keyword">new</span> FileSystemResource(<span class="keyword">new</span> File(srcPath[i]));</span><br><span class="line">            helper.addInline(resIds[i],res);</span><br><span class="line">        &#125;</span><br><span class="line">        javaMailSender.send(message);</span><br><span class="line">    &#125;<span class="keyword">catch</span>(MessageingException e)&#123;</span><br><span class="line">        System.out.println(<span class="string">"Send Fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送邮件时分别传入图片资源路径和资源id，通过FileSystemResource构造静态资源，然后addInline方法将资源加入邮件对象中。</p>
</li>
<li></li>
</ol>
<h2 id="二、定时任务"><a href="#二、定时任务" class="headerlink" title="二、定时任务"></a>二、定时任务</h2><p>定时任务是企业开发的常见功能之一，简单的定时任务可以直接通过Spring中的@Scheduled注解来实现，复杂的定时任务可以通过集成Quartz来实现。</p>
<h3 id="1、-Scheduled"><a href="#1、-Scheduled" class="headerlink" title="1、@Scheduled"></a>1、@Scheduled</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>Spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>之后在项目启动类中添加@EnableScheduling注解开启定时任务：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(ScheduledApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后通过@Scheduled注解进行配置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySchedule</span></span>&#123;</span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedDelay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fixedDelay:"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fixedRate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"fixedRate:"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Scheduled</span>(initialDelay = <span class="number">1000</span>,fixedRate = <span class="number">2000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialDelay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"initialDelay:"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 * * * * ?"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cron</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"cron:"</span>+<span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解释：</p>
<ul>
<li>通过@Scheduled注解标注一个定时任务，其中fixedDelay = 1000表示在当前任务执行结束后1秒开启另一个任务，fixedRate = 2000表示在当前任务开始执行2秒后开启另一个定时任务，initialDelay = 1000表示首次执行的延迟时间</li>
<li>在@Scheduled注解中也可以使用cron表达式，cron=”0 * * * * ?”表示该定时任务每分钟执行一次。</li>
</ul>
<h3 id="2、Quartz"><a href="#2、Quartz" class="headerlink" title="2、Quartz"></a>2、Quartz</h3><p>Quartz是一个功能丰富的开源作业调度库，使用Quartz可以创建简单或复杂的执行计划，他支持数据库、集群、插件以及邮件，且支持cron表达式，具有极高的灵活性。</p>
<h2 id="三、批处理"><a href="#三、批处理" class="headerlink" title="三、批处理"></a>三、批处理</h2><p>Spring Batch 是一个开源的、全面的、轻量级的批处理框架，通过Spring Batch可以实现强大的批处理应用程序的开发。Spring Batch提供记录/跟踪、事务管理、作业处理统计、作业重启以及资源管理等功能。Spring Batch结合定时任务可以发挥更大的作用。</p>
<p>Spring Batch提供了ItemReader、ItemProcessor和ItemWriter来完成数据的读取、处理以及写出操作，并且可以将批处理的执行状态持久化到数据库中。</p>
<h3 id="在Spring-boot中整合运用SpringBatch"><a href="#在Spring-boot中整合运用SpringBatch" class="headerlink" title="在Spring boot中整合运用SpringBatch"></a>在Spring boot中整合运用SpringBatch</h3><p>情景：</p>
<blockquote>
<p> 现在有一个data.csv文件，文件中保存了4条用户数据，通过批处理框架读取data.csv，将之插入数据表中。</p>
</blockquote>
<ol>
<li><p>首先创建一个Spring Boot Web工程，并添加spring-boot-starter-batch以来以及数据库相关依赖，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-batch<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在application.yml中配置数据库基本信息（application.properties同理）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">		<span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">		<span class="attr">password:</span> <span class="string">admin</span></span><br><span class="line">		<span class="attr">url:</span> <span class="string">jdbc:mysql:///batch</span></span><br><span class="line">		<span class="attr">schema:</span> <span class="string">classpath:/org/springframework/batch/core/schema-mysql.sql</span></span><br><span class="line">	<span class="attr">batch:</span></span><br><span class="line">		<span class="attr">initialize-schema:</span> <span class="string">always</span></span><br><span class="line">		<span class="attr">job:</span></span><br><span class="line">			<span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>type、username、password、url配置是数据的基本配置，此处不赘述；</li>
<li>schema：配置项目启动时创建数据表的SQL脚本，该脚本由Spring Batch提供；</li>
<li>initialize-schema：表示在项目启动时执行建表SQL</li>
<li>spring.batch.job.enabled：禁止Spring batch自动执行。在默认的情况下，项目启动时就行执行配置好的批处理操作；而添加了此处的配置之后，便不会自动执行，需要用户手动触发执行，例如发送一个请求，在Controller的接口中出发批处理执行操作。</li>
</ul>
</li>
<li><p>之后在项目启动类中，添加@EnableBatchProcessing注解开启Spring Batch支持，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableBatchProcessing</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchApplication</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        SpringApplication.run(BatchApplication<span class="class">.<span class="keyword">class</span>,<span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="4">
<li><p>接下来对批处理进行配置，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CsvBatchJobConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobBuilderFactory jobBuilderFactory;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StepBuilderFactory stepBuilderFactory;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource dataSource;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@StepScope</span></span><br><span class="line">    <span class="function">FlatFileItemReader&lt;User&gt; <span class="title">itemReader</span><span class="params">()</span></span>&#123;</span><br><span class="line">        FlatFileItemReader&lt;User&gt; reader = <span class="keyword">new</span> FlatFileItemReader&lt;&gt;();</span><br><span class="line">        reader.setLinesToSkip(<span class="number">1</span>);</span><br><span class="line">        reader.setResource(<span class="keyword">new</span> ClassPathResource(<span class="string">"data.csv"</span>));</span><br><span class="line">        reader.setLineMapper(<span class="keyword">new</span> DefaultLineMapper&lt;User&gt;(&#123;&#123;</span><br><span class="line">            setLineTokenizer(<span class="keyword">new</span> DelimitedLineTokenizer()&#123;&#123;</span><br><span class="line">                setNames(<span class="string">"id"</span>,<span class="string">"username"</span>,<span class="string">"address"</span>,<span class="string">"gender"</span>);</span><br><span class="line">                setDelimiter(<span class="string">"\t"</span>);</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">            setFieldSetMapper(<span class="keyword">new</span> BeanWrapperFieldSetMapper&lt;User&gt;()&#123;&#123;</span><br><span class="line">                setTargetType(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125;&#125;)</span><br><span class="line">        &#125;&#125;));</span><br><span class="line">        <span class="keyword">return</span> reader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">JdbcBatchItemWriter <span class="title">jdbcBatchItemWriter</span><span class="params">()</span></span>&#123;</span><br><span class="line">        JdbcBatchItemWriter writer = <span class="keyword">new</span> JdbcBatchItemWriter();</span><br><span class="line">        writer.setDataSource(dataSource);</span><br><span class="line">        writer.setSql(<span class="string">"insert into user(id,username,address,gender) "</span>+<span class="string">"value(:id,:username,:address,:gender)"</span>);</span><br><span class="line">        writer.setItemSqlParameterSourceProvider(</span><br><span class="line">        	<span class="keyword">new</span> BeanPropertyItemSqlParameterSourceProvider&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> writer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Step <span class="title">csvStep</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stepBuilderFactory.get(<span class="string">"csvStep"</span>)</span><br><span class="line">            .&lt;User,User&gt;chunk(<span class="number">2</span>)</span><br><span class="line">            .reader(itemReader())</span><br><span class="line">            .writer(jdbcBatchItemWriter())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Job <span class="title">csvJob</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jobBuilderFactory.get(<span class="string">"csvJob"</span>)</span><br><span class="line">            .start(csvStep())</span><br><span class="line">            .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码含义：</p>
<ol>
<li><p>创建CsvBatchJobConfig进行Spring Batch配置，同时注入JobBuilderFactory，StepBuilderFactory 以及 DataSource备用，其中JobBuilderFactory将用来构建Job，StepBuilderFactory用来构建Step，DataSource则用来支持持久化操作，这里持久化的方案是Spring-Jdbc；</p>
</li>
<li><p>配置一个ItemReader，Spring Batch提供了一些常用的ItemReader，例如JdbcPagingItemReader用来读取数据库中的数据，StaxEventItemReader用来读取XML数据，本案例中的FlatFileReader则是一个加载普通文件的ItemReader，在FlatFileItemReader的配置过程中，</p>
</li>
<li><p>配置ItemWriter，即数据的写出逻辑，SpringBatch也提供了多个ItemWriter的实现。常见的如：</p>
<ul>
<li>FlatFileItemWriter，表示将数据写出为一个普通文件；</li>
<li>StaxEventItemWriter，表示将数据写出为XML</li>
</ul>
<p>另外，还有针对不同数据库提供的写出操作支持类，如MongoItemWriter、JpaItemWriter、Neo4jItemWriter以及HibernateItemWriter等，本案例使用的JdbcBatchItemWriter则是通过JDBC将数据写出到一个关系型数据库中。</p>
<blockquote>
<p>JdbcBatchItemWriter主要配置数据以及数据插入SQL，注意占位符的写法是”:属性名”，最后通过BeanPropertyItemSqlParameterSourceProvider实例将实体类的属性和SQL中的占位符一一映射。</p>
</blockquote>
</li>
<li><p>配置一个Step,Step通过stepBuilderFactory进行配置,首先通过get获取一个StepBuilder,get方法的参数便是该Step的name，之后调用chunk方法的参数2，表示没读取到两条数据就执行一次write操作，最后分别配置reader和writer。</p>
</li>
<li><p>配置一个Job，通过jobBuilderFactory构建一个Job，get方法的参数为Job的name，然后配置该Job的Step即可。</p>
<blockquote>
<p>在这里涉及到一个User实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>data.csv的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id username address gender</span><br><span class="line">1 张三 深圳 男</span><br><span class="line">2 李四 广州 男</span><br><span class="line">3 王五 广州 男</span><br><span class="line">4 赵六 北京 女</span><br></pre></td></tr></table></figure>


</blockquote>
</li>
</ol>
</li>
<li><p>最后，创建Controller，当用户发起一个请求时，触发批处理，demo如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span></span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JobLauncher jobLauncher;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Job job;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            jobLauncher.run(job,<span class="keyword">null</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JobLauncher由框架提供，Job是刚配置的，通过调用JobLauncher中的run方法启动批处理。</p>
</li>
</ol>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ol>
<li>根据User实体类在数据库中创建一个user表；</li>
<li>启动该Springboot项目，访问localhost:8080/hello；</li>
<li>访问成功后，Batch库自动创建处多个批处理相关的表，用来处理批处理的执行状态，同时data.csv中的数据也成功地出入到user表中。</li>
</ol>
<h2 id="四、Swagger2"><a href="#四、Swagger2" class="headerlink" title="四、Swagger2"></a>四、Swagger2</h2><p>在团队开发过程中，前后端分离的项目一般通过构建一份RESTful API文档来描述所有的接口信息，但是这种方法有比较大的弊端：</p>
<ul>
<li>接口太多，编写RESTful API文档工作量太大，因为RESTful API文档不仅仅要包含接口的基本信息，如接口地址，接口请求参数以及接口返回值等等，还需要包含HTTP请求类型，HTTP请求头，请求参数类型，返回值类型，所需权限等等。</li>
<li>维护不方便。当接口发生变化时，就需要修改文档保证文档信息的实时性。</li>
<li>接口测试不方便，一般只能借助第三方工具（如Postman）进行测试。</li>
</ul>
<p>Swagger2是一个开源软件框架啊，可以帮助开发者设计、构建、记录和使用RESTful Web服务，该框架将代码和文档融为一体，可以比较完美地解决以上描述的问题，使开发人员将大部分精力集中到业务中，而不是分散精力在整理繁杂、琐碎的文档中。</p>
<h3 id="Springboot整合Swagger2"><a href="#Springboot整合Swagger2" class="headerlink" title="Springboot整合Swagger2"></a>Springboot整合Swagger2</h3><p>配置pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>接下来配置Swagger2的配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">Docket <span class="title">docket</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">            .select()</span><br><span class="line">            .apis(RequestHandlerSelectors.basePackage(<span class="string">"org.sang.controller"</span>))</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build().apiInfo(<span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                             .description(<span class="string">"接口测试文档"</span>)</span><br><span class="line">                             .contact(<span class="keyword">new</span> Contact(<span class="string">"DevinLPB"</span>,<span class="string">"lpbdevin.xyz"</span>,<span class="string">"252834399@qq.com"</span>))</span><br><span class="line">                            .version(<span class="string">"v1.0"</span>)</span><br><span class="line">                            .title(<span class="string">"API测试文档"</span>)</span><br><span class="line">                            .license(<span class="string">"Apache2.0"</span>)</span><br><span class="line">                            .licenseUrl(<span class="string">"http://www.apache.org/license/LICENSE-2.0"</span>)</span><br><span class="line">                            .build());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li>通过@EnableSwagger2注解启动Swagger2，最主要的是配置一个Docket</li>
<li>通过apis方法配置要扫描的controller位置，通过paths方法配置路径</li>
<li>在apiInfo中构建文档的基本信息，如描述，联系人信息，版本，标题等等。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Api</span>(tags = <span class="string">"用户数据接口"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"查询用户"</span>,notes=<span class="string">"根据id查询用户"</span>)</span><br><span class="line">    <span class="meta">@ApiTmplicitParam</span>(paramType=<span class="string">"path"</span>,name=<span class="string">"id"</span>,value=<span class="string">"用户id"</span>,required=<span class="keyword">true</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserById</span><span class="params">(@PathVariable Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"/user/"</span>+id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiResponses</span>(&#123;</span><br><span class="line">        <span class="meta">@ApiResponse</span>(code=<span class="number">200</span>,message=<span class="string">"删除成功！"</span>),</span><br><span class="line">        <span class="meta">@ApiResponse</span>(code=<span class="number">500</span>,message=<span class="string">"删除失败！"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"删除用户"</span>，notes=<span class="string">"通过id删除用户"</span>)</span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">deleteUserById</span><span class="params">(@PathVariable Integer id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"添加用户"</span>,notes=<span class="string">"添加一个用户，传入用户名和地址"</span>)</span><br><span class="line">    <span class="meta">@ApiImplicitParams</span>(&#123;</span><br><span class="line">        <span class="meta">@ApiImplicitParam</span>(paramType=<span class="string">"query"</span>,name=<span class="string">"username"</span>,value=<span class="string">"用户名"</span>,required=<span class="keyword">true</span>,defaultValue=<span class="string">"devin"</span>)</span><br><span class="line">        <span class="meta">@ApiImplicitParam</span>(paramType=<span class="string">"query"</span>,name=<span class="string">"address"</span>,value=<span class="string">"用户地址"</span>,required=<span class="keyword">true</span>,defaultValue=<span class="string">"shenzhen"</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">addUser</span><span class="params">(@RequestParam String username,@RequestParam String address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username+<span class="string">":"</span>+address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@ApiOperation</span>(value=<span class="string">"修改用户"</span>,notes=<span class="string">"修改用户，传入用户信息"</span>)</span><br><span class="line">    <span class="meta">@PutMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">updateUser</span><span class="params">(@RequestBody User user)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/ignore"</span>)</span><br><span class="line">    <span class="meta">@ApiIgnore</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ingoreMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ApiModel</span>(value=<span class="string">"用户实体类"</span>,description=<span class="string">"用户信息描述类"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value=<span class="string">"用户名"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value=<span class="string">"用户地址"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="comment">//此处省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码解析：</p>
<ul>
<li>@Api注解在类上使用，用于描述整个Controller信息</li>
<li>@ApiOperation注解用在开发方法上，用来描述一个方法的基本信息，value是对方法作用的一个简述，notes用来备注该方法的详细作用。</li>
<li>@ApiImplicitParam注解用在方法上，用来描述方法的参数，paramType是指对方法参数的类型，可选值有path(参数获取方式@PathVariable)、query(参数获取方式@RequestParam)、header(参数获取方式@RequestHeader)、body和form；<ul>
<li>name代表参数名称，和参数变量对应；</li>
<li>value是参数的描述信息；</li>
<li>required表示该字段是否必填；</li>
<li>defaultValue表示该字段的默认值；</li>
</ul>
</li>
<li>@ApiResponse注解是对响应结果的描述，code表示响应码，message表示相应的描述信息，若有多个@ApiResponse，则放在一个@ApiResponses中。</li>
<li>在updateUser方法中，使用@RequestBody注解来接收数据，此时可以通过@ApiMode注解和@ApiModelProperty注解配置User对象的描述信息。</li>
<li>@ApiIgnore注解表示不对某个接口生成文档。</li>
</ul>
<h3 id="测试Swagger2"><a href="#测试Swagger2" class="headerlink" title="测试Swagger2"></a>测试Swagger2</h3><p>启动SpringBoot项目，在浏览器中输入localhost:8080/swagger-ui.html，如果可以正常看到接口文档界面，表示Springboot成功整合Swagger2，恭喜啦~</p>
<h2 id="五、数据校验"><a href="#五、数据校验" class="headerlink" title="五、数据校验"></a>五、数据校验</h2><p>数据校验是开发过程中的一个常见的环节，一般来说，为了提高系统运行效率，都会前端进行数据校验，但在后端同样需要进行数据校验，因为用户还是有可能在获取数据接口后手动传入非法数据，所以后端一样需要进行数据校验。</p>
<p>Springboot也对此有提供了相关的自动化配置解决方案。</p>
<h3 id="一般校验"><a href="#一般校验" class="headerlink" title="一般校验"></a>一般校验</h3><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>项目创建成功后，在LocalValidatorFactoryBean类中，默认的ValidationMessageSource（校验出错时的提示文件）是resource目录下的ValidationMessage.properties文件，故需要在resource目录下创建ValidationMessages.properties文件，内容如下：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">user.name.size</span>=<span class="string">用户名长度介于5到10个字符之间</span></span><br><span class="line"><span class="meta">user.address.notnull</span>=<span class="string">用户地址不能为空</span></span><br><span class="line"><span class="meta">user.age.size</span>=<span class="string">年龄输入不正确</span></span><br><span class="line"><span class="meta">user.email.notnull</span>=<span class="string">邮箱不能为空</span></span><br><span class="line"><span class="meta">user.email.pattern</span>=<span class="string">邮箱格式不正确</span></span><br></pre></td></tr></table></figure>

<p>接下来创建User类，配置数据校验，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Size</span>(min=<span class="number">5</span>,max=<span class="number">10</span>,message=<span class="string">"&#123;user.name.size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="meta">@NotNull</span>(message=<span class="string">"&#123;user.address.notnull&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@DecimalMin</span>(value=<span class="string">"1"</span>,message=<span class="string">"user.age.size"</span>)</span><br><span class="line">    <span class="meta">@DecimalMax</span>(value=<span class="string">"200"</span>,message=<span class="string">"user.age.size"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="meta">@Email</span>(message=<span class="string">"&#123;user.email.pattern&#125;"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message=<span class="string">"&#123;user.email.notnull&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="comment">//setter，getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>@Size表示一个字符串的长度或者一个集合的大小，必须在某一个范围内，min参数表示范围的下限，max参数表示范围的上限；message表示校验失败时候的提示信息。</li>
<li>@NotNull注解表示该字段不能为空</li>
<li>@DecimalMin注解表示对应属性值的下限，@DecimalMax注解表示对应属性值的上限。</li>
<li>@Email注解表示对应属性格式是一个Email</li>
</ul>
<p>以后创建UserController，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addUser</span><span class="params">(@Validated User user,BindingResult result)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span>(ObjectError error:allErrors)&#123;</span><br><span class="line">                errors.add(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errors;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>User参数添加@Validated注解，表示需要对该参数做校验，紧接着BindingResult参数表示在校验出错时保存的出错信息。</li>
<li>若BindingResult中的hasErrors方法返回true，表示有错误信息，此时遍历错误信息，并将其返回到前端。</li>
</ul>
<h3 id="分组校验"><a href="#分组校验" class="headerlink" title="分组校验"></a>分组校验</h3><p>在实际开发中，某一个实体类可能定义了许多的校验规则，但是在某一次业务处理中，并不需要那么多的校验规则，此时可以使用分组检验。</p>
<ol>
<li><p>创建两个分组接口，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup1</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ValidationGroup2</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>在实体类中添加分组信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="meta">@Size</span>(min=<span class="number">5</span>,max=<span class="number">10</span>,message=<span class="string">"&#123;user.name.size&#125;"</span>,groups=ValidationGroup1<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">name</span></span>;</span><br><span class="line">    <span class="meta">@NotNull</span>(message=<span class="string">"&#123;user.address.notnull&#125;"</span>,groups=ValidationGroup2<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">address</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@DecimalMin</span>(value=<span class="string">"1"</span>,message=<span class="string">"&#123;user.age.size&#125;"</span>)</span><br><span class="line">    <span class="meta">@DecimalMin</span>(value=<span class="string">"200"</span>,message=<span class="string">"&#123;user.age.size&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Email</span>(message=<span class="string">"&#123;user.email.pattern&#125;"</span>)</span><br><span class="line">    <span class="meta">@NotNull</span>(message=<span class="string">"&#123;user.email.notnull&#125;"</span>,groups=&#123;ValidationGroup1<span class="class">.<span class="keyword">class</span>,<span class="title">ValidationGroup2</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class">    <span class="title">private</span> <span class="title">String</span> <span class="title">email</span></span>;</span><br><span class="line">    <span class="comment">//省略getter/setter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在部分注解中添加了groups属性，表示该校验规则所属的分组。</p>
</li>
<li><p>在@Validated注解中指定校验分组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span>&#123;</span><br><span class="line">    <span class="meta">@PostMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">addUser</span><span class="params">(@Validated(ValidationGroup2.class)</span> User user,BindingResult result)</span>&#123;</span><br><span class="line">        List&lt;String&gt; errors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(result.hasErrors())&#123;</span><br><span class="line">            List&lt;ObjectError&gt; allErrors = result.getAllErrors();</span><br><span class="line">            <span class="keyword">for</span>(ObjectError error:allErrors)&#123;</span><br><span class="line">                errors.add(error.getDefaultMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> errors;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码中，@Validated(ValidationGroup2.class)表示：这里的校验使用ValidationGroup2分组的校验规则（即对User只校验邮箱地址是否为空，用户地址是否为空）</p>
</li>
<li><p>校验注解</p>
<p>常见的校验注解如下：</p>
<table>
<thead>
<tr>
<th>校验注解</th>
<th>注解的元素类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>AssertFalse</td>
<td>Boolean</td>
<td>被注解的元素值必须为false</td>
</tr>
<tr>
<td>AssertTrue</td>
<td>Boolean</td>
<td>被注解的元素值必须为true</td>
</tr>
<tr>
<td>DecimalMax</td>
<td>BigDecimal,BigInteger,CharSequence<br/>,byte,short,int,long</td>
<td>被注解的元素值小于或等于该注解中的value值</td>
</tr>
<tr>
<td>DecimalMin</td>
<td>BigDecimal,BigInteger,CharSequence<br>,byte,short,int,long</td>
<td>被注解的元素值大于或等于该注解中的value值</td>
</tr>
<tr>
<td>Max</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素值小于或等于该注解中的value值</td>
</tr>
<tr>
<td>Min</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素值大于或等于该注解中的value值</td>
</tr>
<tr>
<td>Digits</td>
<td>BigDecimal,BigInteger,CharSequence,byte<br/>,short,int,long</td>
<td>被注解的元素必须是一个数字、其值必须在可以接收的范围内（整数位数和小数位数在指定范围内）</td>
</tr>
<tr>
<td>Email</td>
<td>CharSequence</td>
<td>被注解的元素值必须是Email格式</td>
</tr>
<tr>
<td>Future</td>
<td>java.util.Date,java.util.Calendar,java.time下的时间类</td>
<td>被注解的元素值必须是一个未来的日期</td>
</tr>
<tr>
<td>Past</td>
<td>java.util.Date,java.util.Calendar,java.time下的时间类</td>
<td>被注解的元素值必须是一个过去的日期</td>
</tr>
<tr>
<td>PastOrPresent</td>
<td>java.util.Date,java.util.Calendar,java.time下的时间类</td>
<td>被注解的元素值必须是一个过去的日期或当前日期</td>
</tr>
<tr>
<td>FutureOrPresent</td>
<td>java.util.Date,java.util.Calendar,java.time下的时间类</td>
<td>被注解的元素值必须是一个未来的日期或当前日期</td>
</tr>
<tr>
<td>Negative</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素必须是负数</td>
</tr>
<tr>
<td>NegativeOrZero</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素必须是负数或0</td>
</tr>
<tr>
<td>Positive</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素必须是正数</td>
</tr>
<tr>
<td>PositiveOrZero</td>
<td>BigDecimal,BigInteger,byte,short,int,long</td>
<td>被注解的元素必须是正数或0</td>
</tr>
<tr>
<td>NotBlank</td>
<td>CharSequence</td>
<td>被注解的元素必须不为null且至少有一个非空白的字符</td>
</tr>
<tr>
<td>NotEmpty</td>
<td>CharSequence,Collection,Map,Array</td>
<td>被注解的字符串不为null或空字符串，被注解的集合或者数组不为空。</td>
</tr>
<tr>
<td>NotNull</td>
<td>任意类型</td>
<td>被注解的元素不为null</td>
</tr>
<tr>
<td>Null</td>
<td>任意类型</td>
<td>被注解的元素为null</td>
</tr>
<tr>
<td>Pattern</td>
<td>CharSequence</td>
<td>被注解的元素必须符合指定的正则表达式</td>
</tr>
<tr>
<td>Size</td>
<td>CharSequence,Collection,Map,Array</td>
<td>被注解的字符串长度、集合或者数组大小必须在指定范围内</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>NotBlank</strong>与<strong>NotEmpty</strong>对比：一个空格的字符串在@NotBlank中验证不会通过，而其在@NotEmpty验证是可以通过的</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Keytool生成Https证书</title>
    <url>/2020/01/09/Java/Keytool%E7%94%9F%E6%88%90Https%E8%AF%81%E4%B9%A6/</url>
    <content><![CDATA[<h1 id="利用JDK中的Keytool生成Https证书"><a href="#利用JDK中的Keytool生成Https证书" class="headerlink" title="利用JDK中的Keytool生成Https证书"></a>利用JDK中的Keytool生成Https证书</h1><h2 id="Https证书"><a href="#Https证书" class="headerlink" title="Https证书"></a>Https证书</h2><p>Https具有良好的安全性，在开发过程中得到了越来越广泛的应用，如微信公众号、小程序等等的开发都要使用https来完成。</p>
<p>国内有些云服务器厂商可以提供免费的https证书，一个账号也可以申请多个。在Java的JDK中也提供了一个Java数字证书管理工具——keytool，存在于jdk/bin目录下，可以通过该工具生成自己的一个数字证书。</p>
<h2 id="Keytool生成Https证书"><a href="#Keytool生成Https证书" class="headerlink" title="Keytool生成Https证书"></a>Keytool生成Https证书</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">keytool -genkey -alias tomcathttps -keyalg RSA -keysize 2048 -keystore lpb.devin -validity 365</span><br></pre></td></tr></table></figure>

<p>解释：</p>
<ul>
<li>-genkey：创建一个新的密钥;</li>
<li>-alias：keystore的别名;</li>
<li>-keyalg：使用的加密算法为RSA;</li>
<li>-keysize：密钥的长度;</li>
<li>-keystore：生成的密钥的存放位置;</li>
<li>-validity：密钥的有效时间，单位天;</li>
</ul>
<h2 id="证书使用"><a href="#证书使用" class="headerlink" title="证书使用"></a>证书使用</h2><h3 id="Spring-boot中使用Https"><a href="#Spring-boot中使用Https" class="headerlink" title="Spring boot中使用Https"></a>Spring boot中使用Https</h3><p>命令执行后，会在当前目录下生成一个名为lpb.deivn的文件，将该文件发知道项目根目录下，智斗需要在application.yaml中做以下配置（application.properties配置类似）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">	<span class="attr">ssl:</span></span><br><span class="line">		<span class="attr">key-store:</span> <span class="string">lpb.devin</span></span><br><span class="line">		<span class="attr">key-alias:</span> <span class="string">tomcathttps</span></span><br><span class="line">		<span class="attr">key-store-password:</span> <span class="number">123456</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Spring boot中不支持同时在配置中启动http和https。此时需要将配置请求重定向，将Http请求重定向至Https请求。配置方式为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomcatConfig</span></span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function">TomcatServletWebServerFactory <span class="title">tomcatServletWebServerFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">        TomcatServletWebServerFactory factory = <span class="keyword">new</span> TomcatServletWebServerFactory()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">postProcessContext</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">                SecurityConstraint constraint = <span class="keyword">new</span> SecurityConstraint();</span><br><span class="line">                constraint.setUserConstraint(<span class="string">"CONFIDENTIAL"</span>);</span><br><span class="line">                SecurityCollection collection = <span class="keyword">new</span> SecurityCollentint();</span><br><span class="line">                collection.addPattern(<span class="string">"/*"</span>);</span><br><span class="line">                constraint.addCollection(collection);</span><br><span class="line">                context.addConstraint(constraint);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        factory.addAdditionalTomcatConnectors(createTomcatConnector());</span><br><span class="line">        <span class="keyword">return</span> factory;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Connector <span class="title">createTomcatConnector</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connector connector = <span class="keyword">new</span> Connector(<span class="string">"org.apache.coyote.httpll.HttpllNioProtocol"</span>);</span><br><span class="line">        connector.setScheme(<span class="string">"http"</span>);</span><br><span class="line">        connector.setPort(<span class="string">"8080"</span>);</span><br><span class="line">        connector.setSecure(<span class="keyword">false</span>);</span><br><span class="line">        connector.setRedirectPort(<span class="number">8081</span>);</span><br><span class="line">        <span class="keyword">return</span> connector;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置一个TomcatServletWebServerFactory，之后添加一个Tomcat中监听8080端口的Connector，将请求转发到8081上。配置完成后，便可以完成http请求重定向至https端口了。</p>
</blockquote>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>生活笔记【一】</title>
    <url>/2020/01/05/%E7%94%9F%E6%B4%BB/%E3%80%90%E6%96%B0%E5%B9%B4%E7%AC%94%E8%AE%B0%E3%80%912020/</url>
    <content><![CDATA[<h1 id="第一篇生活笔记"><a href="#第一篇生活笔记" class="headerlink" title="第一篇生活笔记"></a>第一篇生活笔记</h1><blockquote>
<p> 暂时不知写啥，那就待续……嘻嘻</p>
</blockquote>
]]></content>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql事务隔离级别和MVCC</title>
    <url>/2020/01/03/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8CMVCC/</url>
    <content><![CDATA[<p>[toc]</p>
<h1 id="Mysql的事务隔离级别"><a href="#Mysql的事务隔离级别" class="headerlink" title="Mysql的事务隔离级别"></a>Mysql的事务隔离级别</h1><p>准备工作：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 事先准备一个基本表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    c <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 准备一条数据</span></span><br><span class="line"> <span class="keyword">INSERT</span> <span class="keyword">INTO</span> t <span class="keyword">VALUES</span>(<span class="number">1</span>, <span class="string">'刘备'</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>效果：</p>
<p> mysql&gt; SELECT * FROM t;<br>+—-+——–+<br>| id | c      |<br>+—-+——–+<br>|  1 | 刘备   |<br>+—-+——–+<br>1 row <strong>in</strong> set (0.01 sec) </p>
</blockquote>
<h2 id="（一）为什么存在多种隔离级别"><a href="#（一）为什么存在多种隔离级别" class="headerlink" title="（一）为什么存在多种隔离级别"></a>（一）为什么存在多种隔离级别</h2><p>如Mysql一般，数据库软件是一个Server/Client（服务器/客户端）架构的软件。</p>
<p>对于同一个服务器来说，可以有若干个客户端与之连接，每个客户端与服务器建立连接之后，我们称该连接为<strong>一个会话</strong>（Session）。我们可以同时在不同的会话中输入各种语句，这些语句可以作为事务的一部分进行处理。不同的会话可以同时发送请求，也就是说服务器可能同时在处理多个事务，这样子就会导致不同的事务可能同时访问到相同的记录。</p>
<p>事务有一个特性：事务的执行结果对其他事务的执行不会造成影响，我们称之为<code>隔离性</code>，理论上在某个事务对某个数据进行访问时，其他事务应该进行排队，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样子的话对性能影响太大，所以设计数据库的大叔提出了各种<code>隔离级别</code>，来最大限度的提升系统并发处理事务的能力，但是这也是以牺牲一定的<code>隔离性</code>来达到的。 </p>
<h2 id="（二）各种隔离级别"><a href="#（二）各种隔离级别" class="headerlink" title="（二）各种隔离级别"></a>（二）各种隔离级别</h2><h3 id="1、未提交读（Read-Uncommitted）"><a href="#1、未提交读（Read-Uncommitted）" class="headerlink" title="1、未提交读（Read Uncommitted）"></a>1、未提交读（Read Uncommitted）</h3><p>如果一个事务读到了另一个未提交事务修改过的数据，那么这种<code>隔离级别</code>就称之为<code>未提交读</code>（英文名：<code>READ UNCOMMITTED</code>），示意图如下：</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>Begin；</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br>（此时读到的数据为’关羽’。）</td>
<td></td>
</tr>
</tbody></table>
<p>如上图，<code>Session A</code>和<code>Session B</code>各开启了一个事务，<code>Session B</code>中的事务先将<code>id</code>为<code>1</code>的记录的列<code>c</code>更新为<code>&#39;关羽&#39;</code>，然后<code>Session A</code>中的事务再去查询这条<code>id</code>为<code>1</code>的记录，那么在<code>未提交读</code>的隔离级别下，查询结果就是<code>&#39;关羽&#39;</code>，也就是说某个事务读到了另一个未提交事务修改过的记录。但是如果<code>Session B</code>中的事务稍后进行了回滚，那么<code>Session A</code>中的事务相当于读到了一个不存在的数据，这种现象就称之为<code>脏读</code>，就像这个样子：</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/RLmbWWew55GdJzrqhNibDpUmiarhibQOzyxZ3qBgyBGS5wkxzMUPSjLKUpzkKzJunBEMe1sJoA2OjJnJapx1mfIXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img"></p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>Begin；</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br>（此时读到的数据为’关羽’。）</td>
<td></td>
</tr>
</tbody></table>
<p><code>脏读</code>违背了现实世界的业务含义，所以这种<code>READ UNCOMMITTED</code>算是十分不安全的一种<code>隔离级别</code>。</p>
<h3 id="2、提交读（Read-Committed）"><a href="#2、提交读（Read-Committed）" class="headerlink" title="2、提交读（Read Committed）"></a>2、提交读（Read Committed）</h3><p>如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种<code>隔离级别</code>就称之为<code>已提交读</code>（英文名：<code>READ COMMITTED</code>），如图所示：</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>Begin；</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’刘备’。）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>COMMIT;</td>
</tr>
<tr>
<td>6</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’关羽’。）</td>
<td></td>
</tr>
</tbody></table>
<p>从图中可以看到，第4步时，由于<code>Session B</code>中的事务尚未提交，所以<code>Session A</code>中的事务查询得到的结果只是<code>&#39;刘备&#39;</code>，而第6步时，由于<code>Session B</code>中的事务已经提交，所以<code>Session B</code>中的事务查询得到的结果就是<code>&#39;关羽&#39;</code>了。</p>
<p>对于某个处在在<code>已提交读</code>隔离级别下的事务来说，只要其他事务修改了某个数据的值，并且之后提交了，那么该事务就会读到该数据的最新值，比方说：</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’刘备’。）</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；（隐式提交）</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’关羽’。）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>UPDATE t SET c =’张飞’ WHERE id=1；（隐式提交）</td>
</tr>
<tr>
<td>6</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’张飞’。）</td>
<td></td>
</tr>
</tbody></table>
<p>我们在<code>Session B</code>中提交了几个隐式事务，这些事务都修改了<code>id</code>为<code>1</code>的记录的列c的值，每次事务提交之后，<code>Session A</code>中的事务都可以查看到最新的值。这种现象也被称之为<code>不可重复读</code>。</p>
<h3 id="3、可重复读（Repeatable-Read）"><a href="#3、可重复读（Repeatable-Read）" class="headerlink" title="3、可重复读（Repeatable Read）"></a>3、可重复读（Repeatable Read）</h3><p>在一些业务场景中，一个事务只能读到另一个已经提交的事务修改过的数据，但是第一次读过某条记录后，即使其他事务修改了该记录的值并且提交，该事务之后再读该条记录时，读到的仍是第一次读到的值，而不是每次都读到不同的数据。那么这种<code>隔离级别</code>就称之为<code>可重复读</code>（英文名：<code>REPEATABLE READ</code>），如图所示：</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’刘备’。）</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；（隐式提交）</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’刘备’。）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>UPDATE t SET c =’张飞’ WHERE id=1；（隐式提交）</td>
</tr>
<tr>
<td>6</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’刘备’。）</td>
<td></td>
</tr>
</tbody></table>
<p>从图中可以看出来，<code>Session A</code>中的事务在第一次读取<code>id</code>为<code>1</code>的记录时，列<code>c</code>的值为<code>&#39;刘备&#39;</code>，之后虽然<code>Session B</code>中隐式提交了多个事务，每个事务都修改了这条记录，但是<code>Session A</code>中的事务读到的列<code>c</code>的值仍为<code>&#39;刘备&#39;</code>，与第一次读取的值是相同的。</p>
<h3 id="4、串行化读（Serializable）"><a href="#4、串行化读（Serializable）" class="headerlink" title="4、串行化读（Serializable）"></a>4、串行化读（Serializable）</h3><p>以上3种隔离级别都允许对同一条记录进行<code>读-读</code>、<code>读-写</code>、<code>写-读</code>的并发操作，如果我们不允许<code>读-写</code>、<code>写-读</code>的并发操作，可以使用<code>SERIALIZABLE</code>隔离级别，示意图如下：</p>
<table>
<thead>
<tr>
<th>发生时间编号</th>
<th>Session A</th>
<th>Session B</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>Begin；</td>
<td></td>
</tr>
<tr>
<td>2</td>
<td></td>
<td>Begin；</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td>UPDATE t SET c =’关羽’ WHERE id=1；</td>
</tr>
<tr>
<td>4</td>
<td>SELECT * FROM t WHERE id=1;<br/>（等待ing）</td>
<td></td>
</tr>
<tr>
<td>5</td>
<td></td>
<td>COMMIT;</td>
</tr>
<tr>
<td>6</td>
<td>SELECT * FROM t WHERE id=1;<br/>（此时读到的数据为’关羽’。）</td>
<td></td>
</tr>
</tbody></table>
<p>如图所示，当<code>Session B</code>中的事务更新了<code>id</code>为<code>1</code>的记录后，之后<code>Session A</code>中的事务再去访问这条记录时就被卡住了，直到<code>Session B</code>中的事务提交之后，<code>Session A</code>中的事务才可以获取到查询结果。</p>
<p><a href="https://mp.weixin.qq.com/s/SCW_3AypO-rSolMcjCxVtA" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/SCW_3AypO-rSolMcjCxVtA</a></p>
<h1 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h1><p>MVCC，全称为： Multi-Version Concurrency Control ，多版本并发控制。</p>
<p>MVCC指的就是在使用<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两种隔离级别的事务在执行普通的<code>SEELCT</code>操作时访问记录的版本链的过程，这样子可以使不同事务的<code>读-写</code>、<code>写-读</code>操作并发执行，从而提升系统性能。<code>READ COMMITTD</code>、<code>REPEATABLE READ</code>这两个隔离级别的一个很大不同就是生成<code>ReadView</code>的时机不同，<code>READ COMMITTD</code>在每一次进行普通<code>SELECT</code>操作前都会生成一个<code>ReadView</code>，而<code>REPEATABLE READ</code>只在第一次进行普通<code>SELECT</code>操作前生成一个<code>ReadView</code>，之后的查询操作都重复这个<code>ReadView</code>就好了。 </p>
]]></content>
      <tags>
        <tag>数据库</tag>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>【年度总结】2019</title>
    <url>/2020/01/01/InformalEssay/%E3%80%90%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93%E3%80%912019/</url>
    <content><![CDATA[<h1 id="【2019】年度总结"><a href="#【2019】年度总结" class="headerlink" title="【2019】年度总结"></a>【2019】年度总结</h1><blockquote>
<p>从零到一的过程，往往最能让人印象深刻</p>
</blockquote>
<p>该篇文章，记录了我在2019年主要的所知、所遇、所思、所感，并作为总结分享给各位朋友，也作为给即将离开大学校园的自己一个小小的交代，为迎接更好的2020做充分的准备。</p>
<h3 id="3月-6月：大三春招篇"><a href="#3月-6月：大三春招篇" class="headerlink" title="3月-6月：大三春招篇"></a>3月-6月：大三春招篇</h3><h3 id="8月-10月：秋招篇"><a href="#8月-10月：秋招篇" class="headerlink" title="8月-10月：秋招篇"></a>8月-10月：秋招篇</h3><h3 id="10-12月：实习篇"><a href="#10-12月：实习篇" class="headerlink" title="10-12月：实习篇"></a>10-12月：实习篇</h3>]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>技术书籍推荐</title>
    <url>/2019/12/26/InformalEssay/%E6%8A%80%E6%9C%AF%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<h3 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h3><ul>
<li>Js高级程序设计</li>
<li>Js语言精粹</li>
<li>深入浅出node.js</li>
</ul>
<h3 id="C-C"><a href="#C-C" class="headerlink" title="C/C++"></a>C/C++</h3><ul>
<li>C primer Plus 推荐最新版<ul>
<li>指针</li>
<li>内存管理</li>
</ul>
</li>
<li>C++Primer 和C++ Primer Plus（中文版）</li>
<li>Java编程思想（必看）</li>
<li>Java核心技术（卷一+卷二）</li>
</ul>
<h3 id="python"><a href="#python" class="headerlink" title="python"></a>python</h3><ul>
<li>Python核心编程</li>
<li>Python编程从入门到实践（适合入门）</li>
</ul>
<h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><ul>
<li>Go语言实战</li>
</ul>
<h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><ul>
<li>算法导论（不适合算法初学者）</li>
<li>算法 第四版</li>
<li>数据结构与算法分析</li>
</ul>
<h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><ul>
<li>TCP/IP详解</li>
<li>计算机网络 自顶向下方法</li>
</ul>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>鸟哥的Linux私房菜（系统的使用层面）</li>
<li>进阶：Unix环境高级编程（Linux环境下的编程）</li>
</ul>
<h3 id="Java-EE框架"><a href="#Java-EE框架" class="headerlink" title="Java EE框架"></a>Java EE框架</h3><ul>
<li>Spring boot实战</li>
<li>Spring技术内幕（框架原理）</li>
</ul>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul>
<li>Mysql必知必会</li>
<li>进阶：高性能Mysql</li>
</ul>
<h3 id="提升代码质量"><a href="#提升代码质量" class="headerlink" title="提升代码质量"></a>提升代码质量</h3><ul>
<li>重构：改善代码质量的最佳实践</li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul>
<li>Head First 设计模式</li>
</ul>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA插件推荐</title>
    <url>/2019/12/22/IdeaTools/IDEA%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="IDEA插件推荐"><a href="#IDEA插件推荐" class="headerlink" title="IDEA插件推荐"></a>IDEA插件推荐</h2><h3 id="EasyCode"><a href="#EasyCode" class="headerlink" title="EasyCode"></a>EasyCode</h3>]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud微服务组件</title>
    <url>/2019/12/15/Microservice/SpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="微服务组件"><a href="#微服务组件" class="headerlink" title="微服务组件"></a>微服务组件</h1><h2 id="1、Eureka"><a href="#1、Eureka" class="headerlink" title="1、Eureka"></a>1、Eureka</h2><h4 id="Eureka服务端"><a href="#Eureka服务端" class="headerlink" title="Eureka服务端"></a>Eureka服务端</h4><blockquote>
<p>也称服务注册中心</p>
</blockquote>
<p>Eureka服务端支持高可用配置。如果Eureka以集群模式部署，当集群中存在分片出现故障时候，Eureka会进入自我保护模式。允许在分片故障期间继续提供服务的发现和注册，当故障分片回复运行时，集群中其他的分片会重新将它们的状态再次同步回来。</p>
<h4 id="Eureka客户端"><a href="#Eureka客户端" class="headerlink" title="Eureka客户端"></a>Eureka客户端</h4><p>处理服务的注册和发现。客户端服务通过注解和参数配置的方式，嵌入在客户端应用程序的代码中，在应用程序运行时，Eurake客户端向注册中心注册自身提供的服务，并周期性地发送心跳更新服务租约。</p>
<p>于此同时，Eureka客户端也能从服务端查询当前注册的服务信息并把他们缓存到本地，进行周期性的更新服务状态。</p>
<h4 id="Eureka-Server"><a href="#Eureka-Server" class="headerlink" title="Eureka Server"></a>Eureka Server</h4><p>实现Eureka Server的高可用实际便是将自己作为服务向其他注册中心注册自己，如此可以形成一组相互注册的服务注册中心，以实现服务清单的相互同步，达到高可用效果。</p>
<h2 id="2、Ribbon"><a href="#2、Ribbon" class="headerlink" title="2、Ribbon"></a>2、Ribbon</h2><h2 id="3、Feign"><a href="#3、Feign" class="headerlink" title="3、Feign"></a>3、Feign</h2><h2 id="4、Hystrix"><a href="#4、Hystrix" class="headerlink" title="4、Hystrix"></a>4、Hystrix</h2><h2 id="5、Zuul"><a href="#5、Zuul" class="headerlink" title="5、Zuul"></a>5、Zuul</h2>]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>快速搭建docker服务器环境并进行项目部署</title>
    <url>/2019/12/14/docker/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAdocker%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%8E%AF%E5%A2%83%E5%B9%B6%E8%BF%9B%E8%A1%8C%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="快速搭建Docker服务器环境"><a href="#快速搭建Docker服务器环境" class="headerlink" title="快速搭建Docker服务器环境"></a>快速搭建Docker服务器环境</h1><h1 id="一、快速搭建Docker服务器环境"><a href="#一、快速搭建Docker服务器环境" class="headerlink" title="一、快速搭建Docker服务器环境"></a>一、快速搭建Docker服务器环境</h1><blockquote>
<p><strong>关于Docker</strong></p>
<p>​    当前热门的容器引擎技术。Docker功能强大，涉及知识面也很广，之后会再慢慢、进一步介绍和描述Docker的基础知识。本文主要通过一个实例，演示如何在服务器上快速搭建Docker环境。</p>
</blockquote>
<p>服务器环境：</p>
<ul>
<li>Linux服务器（预装Debian 9.0操作系统）</li>
</ul>
<h2 id="1、安装Docker"><a href="#1、安装Docker" class="headerlink" title="1、安装Docker"></a>1、安装Docker</h2><ol>
<li>通过阿里云镜像安装：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -fsSL https:&#x2F;&#x2F;get.docker.com | bash -s docker --mirror Aliyun</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>查看Docker版本信息：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改daemon配置文件/etc/docker/daemon.json启用加速器，在该文件中添加以下代码：</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"registry-mirrors"</span>: [<span class="string">"https://g6ogy192.mirror.aliyuncs.com"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>配置完成后重启docker</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure>



<h2 id="2、下载Docker镜像"><a href="#2、下载Docker镜像" class="headerlink" title="2、下载Docker镜像"></a>2、下载Docker镜像</h2><p>这里以搭建Mysql为例子：</p>
<p>在<a href="https://hub.docker.com" target="_blank" rel="noopener">hub.docker.com</a>中搜索你需要的镜像：</p>
<p>下图中带有 <code>official</code> 单词的表明为 Dcoker 官方提供的镜像 </p>
<p><img src=".%5CdockerPullMysql1.png" alt="image-20191214211901396"></p>
<p>图中的 <code>8.0.18</code> 至 <code>5.6.46</code> 四行表示支持的 <code>mysql</code> 版本, 同时附带镜像构建的 <code>Dockerfile</code> 文件<br> 右侧的 <code>docker pull mysql</code> 是镜像的下载命令, 此时我们可以在命令行中执行该命令进行下载, 默认下载版本为 <code>latest</code><br> 如果希望指定下载版本, 使用如下命令格式 <code>docker pull mysql:版本号</code>, 如 <code>docker pull mysql:5.6</code></p>
<p><img src=".%5CdockerPullMysql2.png" alt="image-20191214221405653"></p>
<ol>
<li><p>下载Mysql镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker pull mysql:5.7</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>运行Mysql镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run --name mysql --rm -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;root mysql:5.7</span><br></pre></td></tr></table></figure>

<p>此时在命令行中会对该容器运行时候的日志进行输出，可以选择一下操作：</p>
<ul>
<li><p>退出：<code>Ctrl+c</code></p>
</li>
<li><p>后台运行：运行镜像时候加上 <code>-d</code> 参数</p>
<blockquote>
<p>运行参数说明：</p>
<ul>
<li>–name mysql #镜像运行的容器名称为mysql</li>
<li>–rm      #容器退出后删除该容器</li>
<li>-p          3306:3306   #将本机的3306端口映射到该容器的3306端口</li>
<li>-e          MYSQL_ROOT_PASSWORD=root   #为容器配置一个名称MYSQL_ROOT_PASSWORD，值为root的环境变量，mysql容器必须配置该环境变量</li>
<li>-d          #在后台运行该容器</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>测试容器</p>
<p>后台运行Mysql容器后，执行<code>docker ps</code>查看容器列表，可以发现mysql容器已经在后台运行了</p>
</li>
</ol>
<h2 id="3、创建Docker容器运行项目"><a href="#3、创建Docker容器运行项目" class="headerlink" title="3、创建Docker容器运行项目"></a>3、创建Docker容器运行项目</h2><h1 id="二、项目部署"><a href="#二、项目部署" class="headerlink" title="二、项目部署"></a>二、项目部署</h1>]]></content>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA 快捷键大全</title>
    <url>/2019/12/07/IdeaTools/IDEA-%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<p>[toc]</p>
<h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>Ctrl + Shift + A 快捷键可以查找 Intellij 的所有命令，且有带有其快捷键信息，可谓一大神键，也适合我们了解、学习快捷键的工具。</p>
</blockquote>
<h3 id="自动代码快捷键"><a href="#自动代码快捷键" class="headerlink" title="自动代码快捷键"></a>自动代码快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键（括号内为笔记解释）</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + Alt + O</td>
<td align="center">优化导入的类和包</td>
</tr>
<tr>
<td align="center">Alt + Insert</td>
<td align="center">生成代码(如get,set方法,构造函数等)</td>
</tr>
<tr>
<td align="center">fori/sout/psvm + Tab</td>
<td align="center">快捷生成 循环/输出/main函数</td>
</tr>
<tr>
<td align="center">Ctrl+Alt+T</td>
<td align="center">生成try catch</td>
</tr>
<tr>
<td align="center">Ctrl + O （Override）</td>
<td align="center">重写方法</td>
</tr>
<tr>
<td align="center">Ctrl + I （Implement）</td>
<td align="center">实现方法</td>
</tr>
<tr>
<td align="center">Ctr+shift+U</td>
<td align="center">大小写转化</td>
</tr>
<tr>
<td align="center">ALT+回车</td>
<td align="center">导入包，自动改正</td>
</tr>
<tr>
<td align="center">ALT + /</td>
<td align="center">代码提示（对应Eclipse）</td>
</tr>
<tr>
<td align="center">Ctrl + J</td>
<td align="center">自动代码</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + J</td>
<td align="center">整合两行为一行</td>
</tr>
<tr>
<td align="center">Ctrl + space</td>
<td align="center">代码提示</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + space</td>
<td align="center">自动补全代码</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + L</td>
<td align="center">格式化代码</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + I</td>
<td align="center">自动缩进</td>
</tr>
<tr>
<td align="center">Ctrl + E</td>
<td align="center">查看最近更改的代码</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + space</td>
<td align="center">类名或接口名提示</td>
</tr>
<tr>
<td align="center">Ctrl + P</td>
<td align="center">方法参数提示</td>
</tr>
<tr>
<td align="center">Ctrl + Q</td>
<td align="center">可以看到当前方法的声明</td>
</tr>
<tr>
<td align="center">Shift + F6</td>
<td align="center">重构-重命名（包、类、方法、变量、注释等）</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + V</td>
<td align="center">提取变量</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="查询快捷键"><a href="#查询快捷键" class="headerlink" title="查询快捷键"></a>查询快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + Shift + Backspace</td>
<td align="center">跳转到上次编辑的地方</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + Left/Right</td>
<td align="center">前后导航编辑过的地方</td>
</tr>
<tr>
<td align="center">Alt + 7</td>
<td align="center">靠左窗口显示当前文件的结构</td>
</tr>
<tr>
<td align="center">Ctrl + F12</td>
<td align="center">浮动显示当前文件的结构</td>
</tr>
<tr>
<td align="center">Alt + F7</td>
<td align="center">找到你的函数/变量/类的所有引用到的地方</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + F7</td>
<td align="center">找到你的函数/变量/类的所有引用到的地方</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Alt + N</td>
<td align="center">查找类中的方法或者变量</td>
</tr>
<tr>
<td align="center">double Shift</td>
<td align="center">在项目中的所有目录查找文件</td>
</tr>
<tr>
<td align="center">Ctrl + N</td>
<td align="center">查找类</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + N</td>
<td align="center">查找文件</td>
</tr>
<tr>
<td align="center">Ctrl + G</td>
<td align="center">定位行</td>
</tr>
<tr>
<td align="center">Ctrl + F</td>
<td align="center">在当前窗口查找文本</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + F</td>
<td align="center">在指定窗口查找文本</td>
</tr>
<tr>
<td align="center">Ctrl + R</td>
<td align="center">当前窗口口替换文本</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + R</td>
<td align="center">在指定窗口替换文本</td>
</tr>
<tr>
<td align="center">Alt + Shift + C</td>
<td align="center">查找修改的文本</td>
</tr>
<tr>
<td align="center">Ctrl + E</td>
<td align="center">最近打开的文件</td>
</tr>
<tr>
<td align="center">F3</td>
<td align="center">向下查找关键字出现的位置</td>
</tr>
<tr>
<td align="center">Shift + F3</td>
<td align="center">向上查找关键字出现的位置</td>
</tr>
<tr>
<td align="center">F4</td>
<td align="center">查找变量来源</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + O</td>
<td align="center">弹出显示查找内容</td>
</tr>
<tr>
<td align="center">Ctrl + W</td>
<td align="center">选中代码（连续按会有其他效果）</td>
</tr>
<tr>
<td align="center">F2 / Shift + F2</td>
<td align="center">高亮error/warning快速定位</td>
</tr>
<tr>
<td align="center">Ctrl + UP/Down</td>
<td align="center">光标跳转到第一行或最后一行下</td>
</tr>
<tr>
<td align="center">Ctrl + B</td>
<td align="center">快速打开光标处的类或者方法</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + B</td>
<td align="center">查找所有的子类</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + B</td>
<td align="center">查找变量的类</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + Left/Right</td>
<td align="center">返回到上次浏览过的位置</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Up/Down</td>
<td align="center">上下移动代码</td>
</tr>
<tr>
<td align="center">Ctrl + X</td>
<td align="center">删除行</td>
</tr>
<tr>
<td align="center">Ctrl + D</td>
<td align="center">复制行</td>
</tr>
<tr>
<td align="center">Ctrl + H</td>
<td align="center">显示类结构图</td>
</tr>
<tr>
<td align="center">Ctrl + Q</td>
<td align="center">显示注释文档</td>
</tr>
<tr>
<td align="center">Alt + F1</td>
<td align="center">查找代码所在位置</td>
</tr>
<tr>
<td align="center">Alt + 1</td>
<td align="center">快速打开或隐藏工程面板</td>
</tr>
<tr>
<td align="center">Alt + Left/Right</td>
<td align="center">切换代码视图</td>
</tr>
<tr>
<td align="center">Alt + Up/Down</td>
<td align="center">在方法之间快速移动定位</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + Left/Right</td>
<td align="center">前后导航编辑过的地方</td>
</tr>
<tr>
<td align="center">Alt + 6</td>
<td align="center">查找TODO</td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="其他快捷键"><a href="#其他快捷键" class="headerlink" title="其他快捷键"></a>其他快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Shift + Enter</td>
<td align="center">另起一行</td>
</tr>
<tr>
<td align="center">Ctrl + Shift + Z</td>
<td align="center">取消之前的撤销操作</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + F12</td>
<td align="center">资源管理器打开文件夹</td>
</tr>
<tr>
<td align="center">Alt + F1</td>
<td align="center">查找文件所在目录位置</td>
</tr>
<tr>
<td align="center">Shift + Alt + Insert</td>
<td align="center">竖编辑模式</td>
</tr>
<tr>
<td align="center">Ctrl + F4</td>
<td align="center">关闭当前窗口</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + V</td>
<td align="center">自动导入变量定义</td>
</tr>
<tr>
<td align="center">Ctrl + ~</td>
<td align="center">快速切换方案（如界面外观、代码风格、快捷键映射等）</td>
</tr>
</tbody></table>
<h3 id="调试快捷键"><a href="#调试快捷键" class="headerlink" title="调试快捷键"></a>调试快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Alt + F8</td>
<td align="center">debug时选中，查看值</td>
</tr>
<tr>
<td align="center">Alt + F9</td>
<td align="center">运行至光标处</td>
</tr>
<tr>
<td align="center">F9</td>
<td align="center">恢复程序</td>
</tr>
<tr>
<td align="center">Alt+F10</td>
<td align="center">定位到断点</td>
</tr>
</tbody></table>
<h3 id="重构快捷键"><a href="#重构快捷键" class="headerlink" title="重构快捷键"></a>重构快捷键</h3><table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Ctrl + Alt + Shift + T</td>
<td align="center">弹出重构菜单</td>
</tr>
<tr>
<td align="center">Shift+F6</td>
<td align="center">重命名</td>
</tr>
<tr>
<td align="center">Alt + Delete</td>
<td align="center">安全删除</td>
</tr>
<tr>
<td align="center">Ctrl + Alt + N</td>
<td align="center">内联</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>AboutMe</title>
    <url>/2019/12/02/AboutMe/</url>
    <content><![CDATA[<h1 id="林湃滨"><a href="#林湃滨" class="headerlink" title="林湃滨"></a>林湃滨</h1><blockquote>
<p>A Student  living in GuangZhou China.</p>
</blockquote>
<p>来自：广东省揭阳市</p>
<p>就读学校：广州大学</p>
<p>个人邮箱：【<a href="mailto:252834399@qq.com">252834399@qq.com</a>】</p>
<p>【<a href="https://github.com/LPB-Devin" target="_blank" rel="noopener">GitHub</a>】</p>
<p>【<a href="https://me.csdn.net/weixin_40849588" target="_blank" rel="noopener">CSDN</a>】</p>
<blockquote>
<p>不过以后会比较专心于自己的博客小基地，CSDN社区的账号可能会比以前少花精力了嘻嘻</p>
</blockquote>
]]></content>
      <tags>
        <tag>AboutMe</tag>
      </tags>
  </entry>
  <entry>
    <title>Java正则表达式语法</title>
    <url>/2019/11/05/Java/Java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Deepin】配置Java开发环境</title>
    <url>/2019/11/03/Java/Deepin%E9%85%8D%E7%BD%AEJava%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<h2 id="官网下载JDK"><a href="#官网下载JDK" class="headerlink" title="官网下载JDK"></a>官网下载JDK</h2><h2 id="配置路径"><a href="#配置路径" class="headerlink" title="配置路径"></a>配置路径</h2><p>设置默认JDK版本，以及配置可选JDK版本</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2>]]></content>
      <categories>
        <category>Deepin相关</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【XSS攻击】XSS攻击简介以及预防</title>
    <url>/2019/11/02/XSS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="1、XSS攻击"><a href="#1、XSS攻击" class="headerlink" title="1、XSS攻击"></a>1、XSS攻击</h2><p>XSS是一种常出现在Web应用中的计算机安全漏洞。</p>
<p>Web用户会将代码植入到页面之中，这些代码中包括HTML代码和客户端脚本。攻击者可以利用XSS的漏洞在web页面插入恶意的代码，达到对用户进行恶意攻击的目的。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>众所周知，HTML是一种超文本标记语言，通过一些设定的字符搭配来区分文本和标记，如&lt;title&gt;与&lt;/title&gt;之间的内容能够识别为html页面的标题，&lt;script&gt;与&lt;/script&gt;之间的内容识别为一段JavaScript脚本等等。</p>
<p>而如果在URL的参数中或在动态页面中插入的内容包含这些含有特殊含义的字符时，浏览器会误以为插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序会在用户浏览器中执行。</p>
<h3 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h3><h4 id="存储型XSS（也称持久型XSS）"><a href="#存储型XSS（也称持久型XSS）" class="headerlink" title="存储型XSS（也称持久型XSS）"></a>存储型XSS（也称持久型XSS）</h4><p>持久型XSS的最大特点是：服务器再接收到我们的恶意脚本时会将其做一些处理。例如储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。这就意味着只要访问了这个页面的访客，都有可能会执行这段恶意脚本，因此储存型XSS的危害会更大。</p>
<p>还记得在文章开头提到的留言板的例子吗？那通常就是储存型XSS。当有人在留言内容中插入恶意脚本时，由于服务器要像每一个访客展示之前的留言内容，所以后面的访客自然会接收到之前留言中的恶意脚本而不幸躺枪。</p>
<p>这个过程一般而言只要用户访问这个界面就行了，不像反射型XSS，需要访问特定的URL。</p>
<h4 id="反射型XSS（也称非持久型XSS）"><a href="#反射型XSS（也称非持久型XSS）" class="headerlink" title="反射型XSS（也称非持久型XSS）"></a>反射型XSS（也称非持久型XSS）</h4><p>反射型XSS相对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本。</p>
<p>也就是说想要触发漏洞，需要访问特定的链接才能够实现。</p>
<h4 id="DOM-Based-XSS"><a href="#DOM-Based-XSS" class="headerlink" title="DOM Based XSS"></a>DOM Based XSS</h4><p>前两类的XSS可以通过“数据是否保存在服务器端”进行划分。</p>
<p>而DOM Based XSS是从反射型XSS中单独划分出来的、比较特别的XSS，因为此类XSS的形成原因比较特殊：DOM Based XSS是由于<strong>客户端脚本自身解析不正确</strong>导致的安全问题。</p>
<h2 id="2、XSS危害"><a href="#2、XSS危害" class="headerlink" title="2、XSS危害"></a>2、XSS危害</h2><p>归根结底，XSS的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。</p>
<p>可问题在于尽管一个信息框突然弹出来并不怎么友好，但也不至于会造成什么真实伤害啊。的确如此，但要说明的是，这里拿信息框说事仅仅是为了举个栗子，真正的黑客攻击在XSS中除非恶作剧，不然是不会在恶意植入代码中写上alert（“say something”）的。</p>
<p>实例应用：</p>
<ul>
<li>劫持访问</li>
<li>盗用cookie实现无密码登录</li>
<li>结合CSRF攻击进行恶意请求</li>
</ul>
<h2 id="3、XSS防御"><a href="#3、XSS防御" class="headerlink" title="3、XSS防御"></a>3、XSS防御</h2><p>XSS防御的总体思路，<strong>对输入和URL参数进行过滤，对输出进行编码</strong>。</p>
<h4 id="（1）过滤"><a href="#（1）过滤" class="headerlink" title="（1）过滤"></a>（1）过滤</h4><p>对诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt;等标签进行过滤。</p>
<ul>
<li><strong>白名单和黑名单</strong>：</li>
</ul>
<h4 id="（2）编码"><a href="#（2）编码" class="headerlink" title="（2）编码"></a>（2）编码</h4><p>像一些常见的符号，如&lt;&gt;在输入的时候要对其进行转换编码，这样做浏览器是不会对该标签进行解释执行的，同时也不影响显示效果。</p>
<h4 id="（3）限制"><a href="#（3）限制" class="headerlink" title="（3）限制"></a>（3）限制</h4><p>通过以上的案例我们不难发现xss攻击要能达成往往需要较长的字符串，因此对于一些可以预期的输入可以通过<strong>限制长度强制截断</strong>来进行防御。</p>
<h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
      <categories>
        <category>XSS</category>
      </categories>
      <tags>
        <tag>XSS攻击</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的集合</title>
    <url>/2019/10/29/Java/JavaStructure/</url>
    <content><![CDATA[<p>[TOC]</p>
<blockquote>
<p>Java集合体系结构（容器）主要有Set、LIst、Map三个接口</p>
</blockquote>
<h1 id="一、Collection"><a href="#一、Collection" class="headerlink" title="一、Collection"></a>一、Collection</h1><p><img src="http://static.zybuluo.com/Rico123/eu7lguy7qfpayqroq5l54veq/Collection.jpeg" alt="Set"></p>
<h2 id="1-1-添加一组元素的操作"><a href="#1-1-添加一组元素的操作" class="headerlink" title="1.1 添加一组元素的操作"></a>1.1 添加一组元素的操作</h2><ul>
<li><p>Arrays.asList()</p>
<ul>
<li><p>接受一个数组或用逗号隔开的元素列表，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = </span><br><span class="line">    Arrays.asList(array,<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>);<span class="comment">//array为数组</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>返回一个List对象</p>
</li>
<li><p>该方法只是对所产生的list类型做出了最理想的假设，并没有注意你对他赋予什么样的类型，解决方法：可以在其中间插入一条”线索”，这称为显示类型参数说明，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.&lt;Integer&gt;asList()</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Collections.addAll()</p>
<ul>
<li><p>接受一个Collection对象，以及一个数组或一个用逗号分隔的元素列表，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.addAll(list,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>);</span><br><span class="line"><span class="comment">//将元素添加到list（Collection类型）对象中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>无返回值，操作Collection对象参数</p>
</li>
</ul>
</li>
<li><p>Collection.addAll()</p>
<ul>
<li><p>只能接受另一个Collection对象作为参数，运行起来比较快，但没有前两者灵活，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collection.addAll(list);</span><br></pre></td></tr></table></figure>



</li>
</ul>
</li>
</ul>
<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><blockquote>
<p>List可以将元素维护在特定的序列中，该接口在Collection的基础上添加了大量方法，可以在List的中间插入和删除元素</p>
</blockquote>
<p>List是无序列表，主要实现的类有ArrayList、LinkedList、vertor；</p>
<h3 id="两种List类型"><a href="#两种List类型" class="headerlink" title="两种List类型"></a>两种List类型</h3><h4 id="1、ArrayList"><a href="#1、ArrayList" class="headerlink" title="1、ArrayList"></a>1、ArrayList</h4><blockquote>
<p>可以自动扩充自身尺寸的数组，擅长随机访问元素，但在ArrayList中插入和删除元素时较慢</p>
</blockquote>
<ul>
<li>add()——插入对象</li>
<li>get()——访问对象，需传入”数组下标”，不需[ ]（操作符重载实现）</li>
<li>size()——获取元素数量</li>
</ul>
<h4 id="2、LinkedList"><a href="#2、LinkedList" class="headerlink" title="2、LinkedList"></a>2、LinkedList</h4><blockquote>
<p>链表结构，在List中进行插入和删除操作的代价较低，提供了优化的顺序访问。其在随机访问方面相对比较慢</p>
</blockquote>
<p>LinkedList中还添加了可以使用它作为栈、队列或者双端队列的方法。</p>
<p>泛型在List中的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br></pre></td></tr></table></figure>

<ul>
<li>指定了该容器实例能够保存的类型，可以在编译器防止将错误类型的对象放入到容器中；</li>
<li>在元素从容器中取出的时候，可以不用进行类型转换(因为容器通过泛型已经知道它保存的是什么类型)，在调用get()时会帮你进行类型转换</li>
<li>不需要使用容器中元素的索引时，可以使用foreach选择容器中的每个元素</li>
</ul>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul>
<li>get()：返回指定下标（位置）的元素；</li>
<li>contains()：确定某个对象是否在列表中；</li>
<li>remove()：通过指定对象的引用从List中移除该对象；</li>
<li>indexOf()：通过指定对象的引用返回对象在List中对应的下标位置，不存在则返回-1；</li>
<li>subList()：从较大的List中创建出一个片段，且对subList所产生的列表的修改也会反映到初始列表中，反过来初始列表的修改也会反映到subList产生的列表中；</li>
<li>removeAll()：从List中移除所有的元素；</li>
<li>set()：在指定的索引处（第一个参数），用第二个参数替换该位置的元素；</li>
<li>addAll()：可以在指定位置（第一个参数）插入一段新的列表</li>
<li>isEmpty()：List为空时返回true</li>
<li>clear()：清空List</li>
<li>toArray()：转换为一个数组。</li>
<li>Queue的实现：<ul>
<li>element()：返回列表头（不移除），列表为空时抛出OnSuchElementException异常</li>
<li>offer()：在表尾添加元素</li>
<li>peek()：返回列表头，列表为空时返回null</li>
<li>poll()：移除并返回列表的头，列表为空时返回null</li>
<li>remove()：移除并返回列表的头，列表为空时抛出NoSuchElementException异常</li>
</ul>
</li>
</ul>
<h2 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h2><blockquote>
<p>也是一种设计模式。迭代器是一个对象，用于遍历并选择序列中的对象，而程序员可以不用关心该序列底层的结构</p>
</blockquote>
<p>Java中的Iterator只能单向移动，作用如下：</p>
<ul>
<li>使用方法Iterator()要求容器返回一个Iterator</li>
<li>使用next()获得序列中的下一个元素</li>
<li>使用hasNext()检查序列中是否还有元素</li>
<li>使用remove()将序列中的下一个元素移除</li>
</ul>
<blockquote>
<p>如果只是考虑遍历序列，不打算修改序列对象本身，使用foreach语法会显得更加简洁</p>
</blockquote>
<h3 id="真正的作用"><a href="#真正的作用" class="headerlink" title="真正的作用"></a>真正的作用</h3><p>能够将遍历或修改序列的操作与序列的底层结构分离，它<strong>统一了对容器的访问方式</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(Iterator&lt;Integer&gt; it)</span></span>&#123;</span><br><span class="line">    						<span class="comment">//参数不关心容器是哪种类型</span></span><br><span class="line">    <span class="keyword">while</span>(it.hasNext())&#123;</span><br><span class="line">        <span class="keyword">int</span> i = it.next();</span><br><span class="line">        System.out.print(i+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><blockquote>
<p>Set不保存重复的元素，其基于对象的值来确定归属性</p>
</blockquote>
<p> 实现了Collection接口，且没有额外的功能（Set实际上就是Collection，只是表现出不同的行为）；</p>
<p>Set接口主要实现的类有HashSet和TreeSet。</p>
<p>常用到的Set有HashSet，LinkedHashSet 和 TreeSet。</p>
<blockquote>
<ul>
<li>一般地，如果需要一个访问快速的Set，你应该使用HashSet；</li>
<li>当你需要一个排序的Set，你应该使用TreeSet；</li>
<li>当你需要记录下插入时的顺序时，你应该使用LinedHashSet。</li>
</ul>
</blockquote>
<h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><blockquote>
<p>HashSet，实现了Set接口，使用hash函数存储元素，其中的元素排列没有顺序。其add()、remove()以及 contains()等方法的复杂度为O(1)。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5024744406713321676L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 底层支持，HashMap可以代表一个HashMap，也可以代表一个LinkedHashMap</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> HashMap&lt;E,Object&gt; map;     </span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();    <span class="comment">// 傀儡对象</span></span><br></pre></td></tr></table></figure>

<h4 id="LinkedHashSet——HashSet-子类"><a href="#LinkedHashSet——HashSet-子类" class="headerlink" title="LinkedHashSet——HashSet 子类"></a>LinkedHashSet——HashSet 子类</h4><p>​    HashSet是HashSet的子类，其被委托到HashMap的子类LinkedHashMap进行实现，实现了Set接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Constructs a new, empty linked hash set.  (This package private</span></span><br><span class="line"><span class="comment">  * constructor is only used by LinkedHashSet.) The backing</span></span><br><span class="line"><span class="comment">  * HashMap instance is a LinkedHashMap with the specified initial</span></span><br><span class="line"><span class="comment">  * capacity and the specified load factor.</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>      initialCapacity   the initial capacity of the hash map</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>      loadFactor        the load factor of the hash map</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span>      dummy             ignored (distinguishes this</span></span><br><span class="line"><span class="comment">  *             constructor from other int, float constructor.)</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span>     IllegalArgumentException if the initial capacity is less</span></span><br><span class="line"><span class="comment">  *             than zero, or if the load factor is nonpositive</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> HashSet(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> dummy) &#123;</span><br><span class="line"> map = <span class="keyword">new</span> LinkedHashMap&lt;E,Object&gt;(initialCapacity, loadFactor);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>​    TreeSet委托给TreeMap（其实现了NavigableSet接口）进行实现，实现了NavigableSet接口（SortedSet的扩展）</p>
<p>TreeSet将元素存储在<strong>红黑树</strong>数据结构中，结果有序</p>
<p>TreeSet默认是按照<strong>字典序</strong>排序的，如果想按照字母序排序，可以在TreeSet的构造器中传入String.CASE_INSENTIVE_ORDER比较器(比较器，建立排序顺序的对象)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set = </span><br><span class="line">    <span class="keyword">new</span> TreeSet&lt;String&gt;(String.CASE_INSENTIV_ORDER);</span><br></pre></td></tr></table></figure>



<p>其源码简述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The backing map.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> NavigableMap&lt;E,Object&gt; m;   <span class="comment">// 底层支持</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dummy value to associate with an Object in the backing Map</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">new</span> TreeMap&lt;E,Object&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><blockquote>
<p>典型的先进先出FIFO容器</p>
</blockquote>
<p>相关方法：</p>
<ul>
<li>offer()：在允许的情况下，将一个元素插入到队尾</li>
<li>peek()、element()：在不移除的情况下返回队头<ul>
<li>peek()：队列为空时返回null</li>
<li>element()：队列为空时抛出NoSuchelementException异常</li>
</ul>
</li>
<li>poll()、remove()：移除并返回队头<ul>
<li>poll()：队列为空时返回null</li>
<li>remove()：队列为空时抛出NoSuchelementException异常</li>
</ul>
</li>
</ul>
<h1 id="二、Map"><a href="#二、Map" class="headerlink" title="二、Map"></a>二、Map</h1><p>Map为键值对，主要的实现类有HashMap，TreeMap和HashTable。</p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="Java中HashMap与HashTable的联系与区别"><a href="#Java中HashMap与HashTable的联系与区别" class="headerlink" title="Java中HashMap与HashTable的联系与区别"></a>Java中HashMap与HashTable的联系与区别</h3><h4 id="HashMap与HashTable的联系"><a href="#HashMap与HashTable的联系" class="headerlink" title="HashMap与HashTable的联系"></a>HashMap与HashTable的联系</h4><ol>
<li>都实现了Map接口，保存了Key-Value（键值对）</li>
<li>两者的数据结构类似。HashMap和HashTable都是由数组元素为链表头节点的数组组成。</li>
</ol>
<h4 id="HashMap-与-HashTable-的区别"><a href="#HashMap-与-HashTable-的区别" class="headerlink" title="HashMap 与 HashTable 的区别"></a>HashMap 与 HashTable 的区别</h4><ol>
<li><p>两者继承的父类不同；</p>
<blockquote>
<p>HashMap继承AbstractMap类，而HashTable继承Dictionary类。</p>
</blockquote>
</li>
<li><p>HashMap是线程不安全的，而HashTable是线程安全的；</p>
<ol>
<li>HashMap在外部没有做同步处理的情况下，是非Synchronize（同步）的，不能保证在多并发条件下对数据的保护，容易产生脏数据；</li>
<li>HashTable中的方法是Synchronize的；可以在多并发环境下直接使用HashTable；</li>
</ol>
<blockquote>
<p>在单核CPU中HashMap的效率是比HashTable高的，而HashTable更适合在多线程中使用。</p>
</blockquote>
</li>
<li><p>提供contains：</p>
<ol>
<li>HashMap没有contians，只有containsKey和containsValue，认为contians会容易引起误解；</li>
<li>HashTable保留了contains，containsValue和containsKey方法。（但contains和containsValue的功能是相同的）</li>
</ol>
</li>
<li><p>对key和value的空值允许情况：</p>
<ol>
<li>HashMap中key和value都不允许为null；</li>
<li>HashTable中空值可以作为Key，也可以有一个/多个Key的值为空值；（其中的get()方法返回null的意思产生歧义，可能是该Key上的值为null，也可能是不存在该Key）</li>
</ol>
<blockquote>
<p>原因（也是HashMap与HashTable的区别之一）：当变量为null时，其hashcode（哈希值）也为null；</p>
<p>而<strong>两者对Key和Value的取值方式不同</strong></p>
<ul>
<li>HashMap中的Key值是直接取变量对应的 hashcode值 作为Key；</li>
<li>HashTable中会通过hash运算计算获取Value对应的Key；</li>
</ul>
</blockquote>
</li>
<li><p>HashMap和HashTable内部的数组初始化和扩容方式也不相同</p>
<ol>
<li>HashMap的hash数组默认长度大小为16，扩容方式为2的指数：<ul>
<li>length_HashMap = 16 * 2<sup>n</sup>（n为扩容次数）</li>
</ul>
</li>
<li>HashTable的hash数组默认长度大小为11，扩容方式为两倍加一：<ul>
<li>length_HashTable = (上一次HashTable数组长度) * 2 + 1</li>
</ul>
</li>
</ol>
</li>
</ol>
<h3 id="Java1-8的HashMap有什么改进吗？"><a href="#Java1-8的HashMap有什么改进吗？" class="headerlink" title="Java1.8的HashMap有什么改进吗？"></a>Java1.8的HashMap有什么改进吗？</h3><ul>
<li>1.8对HashMap的数据结构进行了改进，增加了判断是否变形为红黑树的阈值；1.7的HashMap使用链地址法进行哈希存储的，其中存在的明显的缺点便是当哈希因子所在的链表过长的时候，效率会很低；在1.8中增加了<strong>判断是否变形成为红黑树</strong>，它有一个阈值（8），当达到这个值时，链表便会变形成为红黑树。</li>
<li>1.8解决了resize时会造成死循环的问题。在1.7之中采用的是头插法，所以在迁移元素的时候，会将元素的顺序改变；1.8采用的是尾插法，能够很快的解决问题。</li>
</ul>
<h3 id="HashMap为什么要满足2n扩容"><a href="#HashMap为什么要满足2n扩容" class="headerlink" title="HashMap为什么要满足2n扩容"></a>HashMap为什么要满足2n扩容</h3><p>在resize时，key的hash值是要进行位运算的，初始容量为16（即2<sup>4</sup>），二进制表示为10000，将其二进制进行（n-1）&amp;hash；其中n-1得到01111，与hash值与运算便可保留前四位的值，结果与取余差不多，但效率比取余高，扩容满足2<sup>n</sup>的话，就依然能够保留二进制算法。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JpaPagingQuery</title>
    <url>/2019/10/24/Jpa/JpaPagingQuery/</url>
    <content><![CDATA[<h1 id="JPA分页查询方法"><a href="#JPA分页查询方法" class="headerlink" title="JPA分页查询方法"></a>JPA分页查询方法</h1><p>JpaRepository接口有提供如下表中所述的内置查询</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>List findAll()</td>
<td>返回所有实体</td>
</tr>
<tr>
<td>List findAll(Iterable ids)</td>
<td>返回指定id的所有实体</td>
</tr>
<tr>
<td>T getOne(ID id)</td>
<td>根据id返回对应的实体，如果没找到，则返回null</td>
</tr>
<tr>
<td>List findAll(Sort sort)</td>
<td>返回所有实体，按照指定顺序返回</td>
</tr>
<tr>
<td>Page findAll(Pageable pageable)</td>
<td>返回实体列表，实体的offset和limit通过pageable来指定</td>
</tr>
</tbody></table>
<p>重点查看第五个方法</p>
<ul>
<li>pageRequest是Pageable的实现类，可以通过以下方法创建：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> page 从0开始，表示查询页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> size 每页显示页数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> page 从0开始，表示查询页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> size 每页显示页数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> sort 排序方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> size,Sort sort)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> page 从0开始，表示查询页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> size 每页显示页数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Param</span> direction 降序/升序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PageRequest <span class="title">of</span><span class="params">(<span class="keyword">int</span> page,<span class="keyword">int</span> size,Direction direction,String ... properties)</span></span>;</span><br></pre></td></tr></table></figure>



<ul>
<li>Page类</li>
</ul>
<ol>
<li>int getTotalPages() ：获取总页数</li>
<li>long getTotalElements()：返回总数</li>
<li>List getContent()：返回某页的结果集</li>
</ol>
<h2 id="EG"><a href="#EG" class="headerlink" title="EG"></a>EG</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span>(strategy = GenerationType.IDENTITY)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">private</span> String sex;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">255</span>)</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> id,String name,String sex,Strintg address)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.sex = sex;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//getter , setter and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserRepository</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>,<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJpaQuery</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PageRequest pageRequest = PageRequest.of(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    Page&lt;User&gt; page = userRepository.findAll(pageRequest);</span><br><span class="line">    List&lt;User&gt; users = page.getContent();</span><br><span class="line">    <span class="keyword">for</span>(User u : users)&#123;</span><br><span class="line">        System.out.println(u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>分页查询</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【Netty】Netty简介</title>
    <url>/2019/10/21/Netty/%E3%80%90Netty%E3%80%91Netty%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="【Netty】初探"><a href="#【Netty】初探" class="headerlink" title="【Netty】初探"></a>【Netty】初探</h1><h2 id="走进Java-NIO"><a href="#走进Java-NIO" class="headerlink" title="走进Java NIO"></a>走进Java NIO</h2><h3 id="同步阻塞BIO"><a href="#同步阻塞BIO" class="headerlink" title="同步阻塞BIO"></a>同步阻塞BIO</h3><p>同步阻塞I/O，服务器实现模式为一个连接一个线程，即<strong>客户端有连接请求时服务器就需要启动一个线程进行处理</strong>，如果这个连接不做任何事情会造成不必要的线程开销，可以通过<strong>线程池机制</strong>来改善。</p>
<p>BIO方式适用于<strong>连接数目比较小且固定的架构</strong>，这种方式对服务端资源要求比较高，并发局限于应用中，在jdk1.4以前是唯一的io，但程序直观简单易理解</p>
<h3 id="伪同步I-O"><a href="#伪同步I-O" class="headerlink" title="伪同步I/O"></a>伪同步I/O</h3><h3 id="同步非阻塞NIO（New-IO-Non-block-IO）"><a href="#同步非阻塞NIO（New-IO-Non-block-IO）" class="headerlink" title="同步非阻塞NIO（New IO/Non-block IO）"></a>同步非阻塞NIO（New IO/Non-block IO）</h3><p>同步非阻塞IO，服务器实现模式为<strong>一个请求一个线程</strong>，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有io请求时候，会启动一个线程进行处理。</p>
<p>NIO适用于<strong>连接数目多且连接短</strong>的架构，比如聊天服务器，并发局限于应用中，编程比较复杂。在jdk1.4开始支持。</p>
<h3 id="异步非阻塞AIO"><a href="#异步非阻塞AIO" class="headerlink" title="异步非阻塞AIO"></a>异步非阻塞AIO</h3><p>异步非阻塞io，也称NIO.2，服务器实现模式为<strong>一个有效请求一个线程</strong>，客户端IO请求都是<strong>操作系统先完成了再通知服务器启动线程进行处理</strong>。</p>
<p>AIO适用于<strong>连接数目多且连接比较长（重操作）</strong>的架构，如相册服务器，充分调用OS参与并发操作，编程比较复杂，jdk1.7开始支持。</p>
<h3 id="IO和NIO的区别"><a href="#IO和NIO的区别" class="headerlink" title="IO和NIO的区别"></a>IO和NIO的区别</h3><ul>
<li>IO面向流，NIO面向缓冲区</li>
<li>IO的各个流是阻塞的，NIO是非阻塞模式</li>
</ul>
<h3 id="四种IO的区别"><a href="#四种IO的区别" class="headerlink" title="四种IO的区别"></a>四种IO的区别</h3><h2 id="Netty入门应用"><a href="#Netty入门应用" class="headerlink" title="Netty入门应用"></a>Netty入门应用</h2><h3 id="Netty架构深入解析"><a href="#Netty架构深入解析" class="headerlink" title="Netty架构深入解析"></a>Netty架构深入解析</h3><h2 id="Java多线程编程在Netty中的应用"><a href="#Java多线程编程在Netty中的应用" class="headerlink" title="Java多线程编程在Netty中的应用"></a>Java多线程编程在Netty中的应用</h2><h2 id="Netty的未来"><a href="#Netty的未来" class="headerlink" title="Netty的未来"></a>Netty的未来</h2>]]></content>
      <categories>
        <category>Netty基础</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>【Redis】Redis简介</title>
    <url>/2019/10/21/Redis/%E3%80%90Redis%E3%80%91Redis%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h2><p>Redis 是完全开源免费的，遵守 BSD 协议，是一个高性能的 key - value 数据库</p>
<p>Redis 与 其他 key - value 缓存产品有以下三个特点：</p>
<ul>
<li>Redis 支持数据持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。</li>
<li>Redis 不仅仅支持简单的 key - value 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储</li>
<li>Redis 支持数据的备份，即 master - slave 模式的数据备份</li>
</ul>
<h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><table>
<thead>
<tr>
<th align="center">结构类型</th>
<th align="center">结构存储的值</th>
<th align="center">读写能力</th>
</tr>
</thead>
<tbody><tr>
<td align="center">String</td>
<td align="center">可以是字符串，整数或者浮点数</td>
<td align="center">可以对整个字符串或者字符串中的一部分进行操作，对整数和浮点数执行自增或者自减操作</td>
</tr>
<tr>
<td align="center">List</td>
<td align="center">一个链表，链表上的每个节点都包含一个字符串</td>
<td align="center">从链表两端添加元素或者弹出元素，<strong>根据偏移量对链表进行修剪</strong>；读取单个或者多个元素，根据值查找或溢出元素</td>
</tr>
<tr>
<td align="center">Set</td>
<td align="center">包含字符串的无序集合，且其中的每个字符串都是各不相同的</td>
<td align="center">添加、获取、删除单个元素，检查一个元素是否存在于集合中，计算交集、并集、差集；从集合中随机获取元素</td>
</tr>
<tr>
<td align="center">Hash</td>
<td align="center">包含键值对的无序哈希表</td>
<td align="center">添加、获取、删除单个键值对，获取所有键值对</td>
</tr>
<tr>
<td align="center">Zset</td>
<td align="center">字符串成员与浮点数分支之间的有序映射，元素的排列顺序由分值的大小决定</td>
<td align="center">添加、获取、删除单个元素，根据分支范围（range）或者成员来获取元素。</td>
</tr>
</tbody></table>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>redis事务一次可以执行多条命令，服务器在执行命令期间，不会执行其他客户端的命令请求。</p>
<p>事务中的一条或多条命令被一次性发送到服务器，并不是逐条发送，此种方式被称为流水线，可以减少客户端与服务器之间的网络通信次数，提升性能。</p>
<p>Redis一般的事务实现方式：使用MULTI和EXEC命令将事务操作包起来：</p>
<ol>
<li>批量操作在发送EXEC命令前被放入队列缓存；</li>
<li>收到EXEC命令后进入事务执行，事务中任意命令执行失败，其余命令依然被执行。也就是说Redis事务不保证原子性；</li>
<li>在事务执行过程中，其他客户端提交的命令不会插入到事务执行命令序列中；</li>
</ol>
<p>一个事务从开始到执行过程中经历的三个阶段：</p>
<ul>
<li>开始事务；</li>
<li>命令入队；</li>
<li>执行事务；</li>
</ul>
<p>eg：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">MULTI	<span class="comment">--1、开始事务</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--2、命令入队</span></span><br><span class="line"><span class="keyword">SET</span> book-<span class="keyword">name</span> <span class="string">"Mastering C++ in 21 days"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Get</span> book-<span class="keyword">name</span></span><br><span class="line"></span><br><span class="line">SADD tag <span class="string">"C++"</span> <span class="string">"Programming"</span> <span class="string">"Mastering Series"</span></span><br><span class="line"></span><br><span class="line">SMEMBERS tag</span><br><span class="line"></span><br><span class="line">EXEC	<span class="comment">--3、执行事务</span></span><br></pre></td></tr></table></figure>



<blockquote>
<p>单个命令的执行是原子性的，但是Redis没有在事务上增加任何维持原子性的机制，所以Redis事务的执行并不是原子性的。</p>
<p>Redis的事务，可以理解是一个打包好的、批量的执行脚本，但是这些批量的指令并不是原子化的操作，中间某条指令的失败，不会导致事务中之前执行的指令的回滚，也不会导致之后的指令不会执行。</p>
<p>官网相关内容说明：</p>
<p> <em>It’s important to note that even when a command fails, all the other commands in the queue are processed – Redis will not stop the processing of commands</em> </p>
</blockquote>
<h3 id="Redis事务命令"><a href="#Redis事务命令" class="headerlink" title="Redis事务命令"></a>Redis事务命令</h3><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DISCARD</td>
<td align="center">取消事务，放弃执行事务块内的所有命令</td>
</tr>
<tr>
<td align="center">EXEC</td>
<td align="center">执行所有事务块内的命令</td>
</tr>
<tr>
<td align="center">MULTI</td>
<td align="center">标记事务块的开始</td>
</tr>
<tr>
<td align="center">UNWATCH</td>
<td align="center">取消Watch命令对所有key的监视</td>
</tr>
<tr>
<td align="center">WATCH key [key …]</td>
<td align="center">监视一个/多个key，如果在事务执行之前这个/些 key 被其他命令改动<br>则该事务将被打断</td>
</tr>
</tbody></table>
<h2 id="Redis-持久化"><a href="#Redis-持久化" class="headerlink" title="Redis 持久化"></a>Redis 持久化</h2><p>Redis 是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p>
<h3 id="（1）RDB-持久化"><a href="#（1）RDB-持久化" class="headerlink" title="（1）RDB 持久化"></a>（1）RDB 持久化</h3><p>将某个时间点的所有数据都存放到硬盘上。</p>
<p>可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。</p>
<p>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</p>
<p>如果数据量大，保存快照的时间会很长。</p>
<h3 id="（2）AOF-持久化"><a href="#（2）AOF-持久化" class="headerlink" title="（2）AOF 持久化"></a>（2）AOF 持久化</h3><p>将写命令添加到 AOF 文件（append only file）末尾。</p>
<p>使用 AOF 持久化需要设置同步选项，从而确保<strong>写命令</strong>同步到磁盘文件上的时机。</p>
<p>这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓冲区，然后由操作系统决定什么时候同步到磁盘。</p>
<p>选项同步频率always每个写命令都同步eyerysec每秒同步一次no让操作系统来决定何时同步</p>
<ul>
<li>always 选项会严重减低服务器的性能</li>
<li>everysec 选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且 Redis 每秒执行一次同步对服务器几乎没有任何影响。</li>
<li>no 选项并不能给服务器性能带来多大的提升，而且会增加系统崩溃时数据丢失的数量。</li>
</ul>
<p>随着服务器写请求的增多，AOF 文件会越来越大。Redis 提供了一种将 AOF 重写的特性，能够去除 AOF 文件中的冗余写命令。</p>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><p>通过使用 slaveof host port 命令来让一个服务器成为另一个服务器的从服务器。</p>
<p>一个从服务器只能有一个主服务器，并且不支持主主复制。</p>
<h3 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h3><ol>
<li>主服务器创建快照文件，即 RDB 文件，发送给从服务器，并在发送期间使用缓冲区记录执行的写命令。</li>
<li>快照文件发送完毕之后，开始像从服务器发送存储在缓冲区的写命令。</li>
<li>从服务器丢弃所有旧数据，载入主服务器发来的快照文件，之后从服务器开始接受主服务器发来的写命令。</li>
<li>主服务器每执行一次写命令，就向从服务器发送相同的写命令。</li>
</ol>
<h3 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h3><p>随着负载不断上升，主服务器无法很快的更新所有从服务器，或者重新连接和重新同步从服务器将导致系统超载。</p>
<p>为了解决这个问题，可以创建一个中间层来分担主服务器的复制工作。中间层的服务器是最上层服务器的从服务器，又是最下层服务器的主服务器。</p>
<h2 id="哨兵"><a href="#哨兵" class="headerlink" title="哨兵"></a>哨兵</h2><p>Sentinel（哨兵）可以监听集群中的服务器，并在主服务器进入下线状态时，自动从从服务器中选举处新的主服务器。</p>
<h2 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h2><p>分片是将数据划分为多个部分的方法，可以将数据存储到多台机器里面，这种方法在解决某些问题时可以获得线性级别的性能提升。</p>
<p>假设有 4 个 Redis 实例 R0, R1, R2, R3, 还有很多表示用户的键 user:1, user:2, … , 有不同的方式来选择一个指定的键存储在哪个实例中。</p>
<ul>
<li>最简单的是范围分片，例如用户 id 从 0 ~ 1000 的存储到实例 R0 中，用户 id 从 1001 ~ 2000 的存储到实例 R1中，等等。但是这样需要维护一张映射范围表，维护操作代价高。</li>
<li>还有一种是哈希分片。使用 CRC32 哈希函数将键转换为一个数字，再对实例数量求模就能知道存储的实例。</li>
</ul>
<p>根据执行分片的位置，可以分为三种分片方式：</p>
<ul>
<li>客户端分片：客户端使用一致性哈希等算法决定应当分布到哪个节点。</li>
<li>代理分片：将客户端的请求发送到代理上，由代理转发到正确的节点上。</li>
<li>服务器分片：Redis Cluster。</li>
</ul>
]]></content>
      <categories>
        <category>Redis基础</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式架构体系</title>
    <url>/2019/10/19/DistributedArchitecture/%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[]]></content>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>Git实现版本控制</title>
    <url>/2019/10/19/Git/VersionControlByGit/</url>
    <content><![CDATA[<h1 id="Git实现项目版本控制"><a href="#Git实现项目版本控制" class="headerlink" title="Git实现项目版本控制"></a>Git实现项目版本控制</h1><blockquote>
<p>Git 与GitHub：Git是一个版本控制工具，而GitHub事一个面向开源以及私有软件项目的托管平台，程序员交流的地方</p>
</blockquote>
<p>本文主要记录git对多人参与的一个项目进行版本控制的手记，如果需要安装和使用git，以及利用git对GitHub仓库项目的操作处理，可以查看文章：<a href="https://blog.csdn.net/weixin_36816337/article/details/81070359" target="_blank" rel="noopener">为项目配置git远程仓库</a></p>
<p>主要学习来源：</p>
<p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方网站</a></p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/2019/10/19/Java/JavaMemoryModel/</url>
    <content><![CDATA[<h1 id="Java内存模型（JMM）"><a href="#Java内存模型（JMM）" class="headerlink" title="Java内存模型（JMM）"></a>Java内存模型（JMM）</h1><p>​    JMM全称Java Memory Model 。其实JMM并不像JVM内存结构一样是真实存在的。他只是一个抽象的概念。</p>
<p>​    JMM是和多线程相关的，他描述了一组规则或规范，这个规范定义了一个线程对共享变量的写入时对另一个线程是可见的。</p>
<h2 id="JMM定义"><a href="#JMM定义" class="headerlink" title="JMM定义"></a>JMM定义</h2><p>​    Java内存模型（Java Memory Model ,JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了Java程序在各种平台下对内存的访问都能得到一致效果的机制及规范。目的是解决由于多线程通过共享内存进行通信时，存在的<strong>原子性</strong>、<strong>可见性</strong>（缓存一致性）以及<strong>有序性</strong>问题。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>​    线程是CPU调度的基本单位。</p>
<p>​    CPU有时间片的概念，会根据不同的调度算法进行线程调度。所以在多线程场景下，就会发生原子性问题。因为线程在执行一个读改写操作时，在执行完读改之后，时间片耗完，就会被要求放弃CPU，并等待重新调度。这种情况下，读改写就不是一个原子操作。即存在原子性问题。</p>
<h3 id="可见性（缓存一致性）"><a href="#可见性（缓存一致性）" class="headerlink" title="可见性（缓存一致性）"></a>可见性（缓存一致性）</h3><p>​    在多核CPU，多线程的场景中，每个核都至少有一个L1 缓存。多个线程访问进程中的某个共享内存，且这多个线程分别在不同的核心上执行，则每个核心都会在各自的caehe中保留一份共享内存的缓冲。由于多核是可以并行的，可能会出现<strong>多个线程同时写各自的缓存</strong>的情况，而各自的cache之间的数据就有可能不同。</p>
<p>​    在CPU和主存之间增加缓存，在多线程场景下就可能存在缓存一致性问题，也就是说，在多核CPU中，每个核的自己的缓存中，关于同一个数据的缓存内容可能不一致。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>​    除了引入了时间片以外，由于处理器优化和指令重排等，CPU还可能对输入代码进行乱序执行，比如load-&gt;add-&gt;save 有可能被优化成load-&gt;save-&gt;add 。这就是有序性问题。</p>
<p>​    为了保证共享内存的正确性（可见性、有序性、原子性），内存模型定义了共享内存系统中多线程程序读写操作行为的规范。通过这些规则来规范对内存的读写操作，从而保证指令执行的正确性。它与处理器有关、与缓存有关、与并发有关、与编译器也有关。他解决了CPU多级缓存、处理器优化、指令重排等导致的内存访问问题，保证了并发场景下的一致性、原子性和有序性。</p>
<p>​    针对上面的这些问题，不同的操作系统都有不同的解决方案，而Java语言为了屏蔽掉底层的差异，定义了一套属于Java语言的内存模型规范，即Java内存模型。</p>
<p><img src="https://i1.go2yd.com/image.php?url=0MXImMlNFB" alt="img"></p>
<h2 id="JMM实现"><a href="#JMM实现" class="headerlink" title="JMM实现"></a>JMM实现</h2><p>​    在Java中提供了一系列和并发处理相关的关键字，比如_volatile_、_synchronized_、_final_、_concurren_包等。其实这些就是Java内存模型封装了底层的实现后提供给程序员使用的一些关键字。</p>
<p>​    在开发多线程的代码的时候，我们可以直接使用synchronized等关键字来控制并发，从来就不需要关心底层的编译器优化、缓存一致性等问题。所以，Java内存模型，除了定义了一套规范，还提供了一系列原语，封装了底层实现后，供开发者直接使用。</p>
<p>​    那么，在Java中，是分别使用什么方式来保证原子性、可见性和有序性呢？</p>
<h3 id="原子性-1"><a href="#原子性-1" class="headerlink" title="原子性"></a>原子性</h3><p>​    在Java中，为了保证原子性，提供了两个高级的字节码指令monitorenter和monitorexit，这两个字节码，在Java中对应的关键字就是synchronized。</p>
<p>​    因此，在Java中可以使用synchronized来保证方法和代码块内的操作是原子性的。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>​    Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值的这种依赖主内存作为传递媒介的方式来实现的。</p>
<p>​    Java中的volatile关键字提供了一个功能，那就是被其修饰的变量在被修改后可以立即同步到主内存，被其修饰的变量在每次是用之前都从主内存刷新。因此，可以使用volatile来保证多线程操作时变量的可见性。</p>
<blockquote>
<p>除了volatile，Java中的synchronized和final两个关键字也可以实现可见性，只不过实现方式不同。</p>
</blockquote>
<h3 id="有序性-1"><a href="#有序性-1" class="headerlink" title="有序性"></a>有序性</h3><p>​    在Java中，可以使用synchronized和volatile来保证多线程之间操作的有序性。实现方式有所区别：</p>
<ul>
<li>volatile关键字会禁止指令重排。</li>
<li>synchronized关键字保证同一时刻只允许一条线程操作。</li>
</ul>
<p>​    在简单介绍完Java并发编程中解决原子性、可见性以及有序性可以使用的关键字后，这个synchronized关键字似乎在每个地方都有它，它可以同时满足以上三种特性，这其实也是很多人滥用synchronized的原因。</p>
<p>但是<strong>synchronized是比较影响性能的</strong>，虽然编译器提供了很多锁优化技术，但是也不建议过度使用。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonDesignMode</title>
    <url>/2019/10/18/designMode/CommonDesignMode/</url>
    <content><![CDATA[<p>[TOC]</p>
<h1 id="常用设计模式"><a href="#常用设计模式" class="headerlink" title="常用设计模式"></a>常用设计模式</h1><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="懒汉式单例"><a href="#懒汉式单例" class="headerlink" title="懒汉式单例"></a>懒汉式单例</h3><p>线程不安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getIntance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>线程安全</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="饿汉式单例"><a href="#饿汉式单例" class="headerlink" title="饿汉式单例"></a>饿汉式单例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="双重校检锁"><a href="#双重校检锁" class="headerlink" title="双重校检锁"></a>双重校检锁</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(singleton == <span class="keyword">null</span>)</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2>]]></content>
      <tags>
        <tag>-设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker容器学习</title>
    <url>/2019/10/16/docker/DockerLearn/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="认识Docker"><a href="#认识Docker" class="headerlink" title="认识Docker"></a>认识Docker</h2><h3 id="Docker是什么？"><a href="#Docker是什么？" class="headerlink" title="Docker是什么？"></a>Docker是什么？</h3><p>Docker类似于集装箱。</p>
<p>Docker是LXC（Linux Containers，Linux容器）的高级容器引擎。是一个软件容器平台。</p>
<p>仓库：docker存放的事 镜像 + 私人镜像 ==》 dockerhub</p>
<p>容器：装东西 –》软件</p>
<p>镜像：软件打成的包，如redis、tomcat、</p>
<h3 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h3><p>一个文本文件</p>
<h2 id="Docker集群"><a href="#Docker集群" class="headerlink" title="Docker集群"></a>Docker集群</h2><p>docker集群化</p>
<p>一键动态扩容</p>
<p>负载均衡</p>
<p>微服务：服务治理（业务逻辑） 构建服务 部署服务</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>【Java】多线程</title>
    <url>/2019/10/16/Java/JavaMultiThread/</url>
    <content><![CDATA[<h1 id="Java中的多线程"><a href="#Java中的多线程" class="headerlink" title="Java中的多线程"></a>Java中的多线程</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="用多线程的目的是什么？"><a href="#用多线程的目的是什么？" class="headerlink" title="用多线程的目的是什么？"></a>用多线程的目的是什么？</h3><p>充分利用cpu资源，并发做多件事。</p>
<h3 id="如何在Java程序中创建一个线程？"><a href="#如何在Java程序中创建一个线程？" class="headerlink" title="如何在Java程序中创建一个线程？"></a>如何在Java程序中创建一个线程？</h3><p>本质：new Thread()</p>
<ol>
<li>继承Thread类</li>
<li>实现Runable接口，重写run()方法。</li>
</ol>
<h3 id="线程是什么？"><a href="#线程是什么？" class="headerlink" title="线程是什么？"></a>线程是什么？</h3><p>一天代码执行流，完成一组代码的执行。（称这段代码为线程的任务）</p>
<h4 id="任务是什么？"><a href="#任务是什么？" class="headerlink" title="任务是什么？"></a>任务是什么？</h4><p>通常我们会把在runnable方法中的run()方法作为一个任务去执行。</p>
<p>任务指的是run()方法中的代码块。</p>
<h3 id="cpu是做什么的？"><a href="#cpu是做什么的？" class="headerlink" title="cpu是做什么的？"></a>cpu是做什么的？</h3><p><strong>任务</strong> –装入》 <strong>线程</strong> –运送》 <strong>CPU1执行代码</strong></p>
<h3 id="多线程是不是越多越好"><a href="#多线程是不是越多越好" class="headerlink" title="多线程是不是越多越好"></a>多线程是不是越多越好</h3><ul>
<li><p>内存问题：线程越多，内存的占用越多；可能会导致内存溢出问题</p>
</li>
<li><p>需要频繁切换线程上下文，影响性能。</p>
</li>
<li><p>线程在Java中是一个对象，每一个Java线程都需要一个操作系统线程支持，线程创建，销毁需要时间，如果 创建时间+销毁时间 》 任务执行时间，效率就很低，很不划算。</p>
</li>
<li><p>Java对象占用堆内存，操作系统线程占用系统内存，根据jvm规范，一个线程默认的最大栈大小为1M，这个栈空间需要从系统内存中分配。<strong>线程太多的话，会消耗很多的内存</strong></p>
</li>
</ul>
<h2 id="1、如何正确使用多线程"><a href="#1、如何正确使用多线程" class="headerlink" title="1、如何正确使用多线程"></a>1、如何正确使用多线程</h2><ol>
<li>目的：充分使用cpu并发做多件事</li>
<li>本质：把代码送给cpu执行</li>
<li>用合适数量的线程(“卡车”)不断运送即可。（这合适数量的线程就构成了一个<strong>池</strong>）</li>
<li>有任务要执行，就放入池中，池中的一个线程就把任务运送到cpu中执行。</li>
</ol>
<h2 id="2、线程池"><a href="#2、线程池" class="headerlink" title="2、线程池"></a>2、线程池</h2><h3 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h3><p>BlockingQueue：堵塞队列，线程安全</p>
<table>
<thead>
<tr>
<th></th>
<th>抛出异常</th>
<th>特殊值</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【框架】SpringCloud总结</title>
    <url>/2019/10/15/JavaFrame/SpringCloudIntroduction/</url>
    <content><![CDATA[<h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1><h2 id="1、单体架构系统与分布式集群"><a href="#1、单体架构系统与分布式集群" class="headerlink" title="1、单体架构系统与分布式集群"></a>1、单体架构系统与分布式集群</h2><h3 id="单体架构系统"><a href="#单体架构系统" class="headerlink" title="单体架构系统"></a>单体架构系统</h3><p>单体架构便是将所有功能都放于一个应用之中。</p>
<p>单体架构系统的特点：</p>
<ul>
<li><p>好处：便于开发、测试、部署也方便，直接打包成jar或war便可。</p>
</li>
<li><p>弊端：高访问，高并发的上限是固定的。 </p>
<blockquote>
<p>比如一个单体架构，能够承受 1000次访问/秒。 但是访问量达到 2000次/秒的时候，就会非常卡顿，严重影响业务，并且仅仅依靠单体架构本身，很难突破这个瓶颈了。</p>
</blockquote>
</li>
</ul>
<h3 id="分布式和集群"><a href="#分布式和集群" class="headerlink" title="分布式和集群"></a>分布式和集群</h3><p>打破单体架构性能瓶颈的问题，</p>
<h2 id="2、微服务的特点"><a href="#2、微服务的特点" class="headerlink" title="2、微服务的特点"></a>2、微服务的特点</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p><strong>技术异构性:</strong></p>
<p>在一个由多个服务相互协作的系统中,可以在不同的服务中使用最适合该服务的技术</p>
<p><strong>弹性:</strong></p>
<p>如果系统中的一个组件不可用了,但并没有导致级联故障,那么系统的其他部分还可以正常运行</p>
<p><strong>扩展:</strong></p>
<p>可以只对那些需要扩属的服务进行扩属</p>
<p><strong>简化部害:</strong></p>
<p>各个服务的部署是独立的,这样就可以更快地对特定部分的代码进行部<br>·与组织结构相匹配:可以很好地将架构与组织结构相匹配,避免出现过大的代码库,从而得凖想团队大小及生产力</p>
<p>可组合性:</p>
<p>不同服务模块的接口可以再进行重用,成为其他产品中的一个组件</p>
<p><strong>对可替代性的优化:</strong></p>
<p>可以在需要时轻易地重写服务,或者删除不再使用的服务</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>1.<strong>运维开销更多的服务也就麻味着更多的运维</strong>,产品团队需要保证所有的相关服务都有完善的监控等基础设施,传统的架构开发者只需要保证一个应用正常运行,而现在却需要保证几十甚至上百道工序高效运转，这是一个艰巨的任务</p>
<p>Devops要求使用微服务架构后,开发团队需要保证一个 Tomcat集群可用,保证一个数据库可用,这就味团队需要高品质的 Devops和自动化技术,而现在,这样的全栈式人才很少,</p>
<p>隐式接口<strong>服务和服务之间通过接口来联系</strong>,当某一个服务更改接口格式时,可能涉及到此接口的所有服<br>务都需要做调整</p>
<p><strong>重复劳动</strong>在很多服务中可能都会使用到同一个功能,而这一功能点投有足够大到提供一个服务的程度,这个时候可能不同的服务团队都会单独开发这一D能,的业务逻,这压背了良好的件工程中的很多</p>
<h2 id="SpringCloud和Dubbo的区别"><a href="#SpringCloud和Dubbo的区别" class="headerlink" title="SpringCloud和Dubbo的区别"></a>SpringCloud和Dubbo的区别</h2><p><img src="https://www.bjsxt.com/wp-content/themes/sxt/statics/images/bjsxt/javamianshiti/images/javaimg41.png" alt=""></p>
<h2 id="SpringCloud基本组件"><a href="#SpringCloud基本组件" class="headerlink" title="SpringCloud基本组件"></a>SpringCloud基本组件</h2><h3 id="1、SpringCloud-Eureka：注册发现中心"><a href="#1、SpringCloud-Eureka：注册发现中心" class="headerlink" title="1、SpringCloud Eureka：注册发现中心"></a>1、SpringCloud Eureka：注册发现中心</h3><h4 id="1-1、建立服务注册与发现中心：eureka-server"><a href="#1-1、建立服务注册与发现中心：eureka-server" class="headerlink" title="1.1、建立服务注册与发现中心：eureka server"></a>1.1、建立服务注册与发现中心：eureka server</h4><ol>
<li>Spring Initializr-》勾选 Eureka Server依赖 ，进行创建注册发现server模块</li>
</ol>
<p>查看pom.xml珠主要内容</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>application.yml内容</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 当前服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-server</span></span><br><span class="line">  <span class="comment">###指定端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">instance:</span></span><br><span class="line">    <span class="comment">###指定注册地址</span></span><br><span class="line">    <span class="attr">hostname:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在运行类中需要加上一个@EnableEurekaServer注解，说明这是一个 服务注册发现 的eureka server</p>
</blockquote>
<h4 id="1-2、建立各个微服务client"><a href="#1-2、建立各个微服务client" class="headerlink" title="1.2、建立各个微服务client"></a>1.2、建立各个微服务client</h4><ol>
<li><p>Spring Initializr-》勾选Spring Web、 Eureka Client依赖 ，进行创建微服务模块</p>
<p>查看pom.xml文件主要内容：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Greenwich.SR3<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p>application.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment">### 当前服务的名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eureka-grade</span></span><br><span class="line">  <span class="comment">### 指定端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://localhost:8080/eureka/</span></span><br><span class="line">    <span class="attr">register-with-eureka:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要在运行类中配置@EnableEurekaClient注解，实现注解</p>
</blockquote>
</li>
</ol>
<h4 id="1-3、实现各个服务之间的通信"><a href="#1-3、实现各个服务之间的通信" class="headerlink" title="1.3、实现各个服务之间的通信"></a>1.3、实现各个服务之间的通信</h4><ol>
<li><p>resttemplate实现微服务之间的调用：</p>
<p>Application类中向IOC容器中注册一个RestTemplate的bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 在Ioc容器中注册一个restTemplate的bean</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@LoadBalanced</span>   <span class="comment">//负载均衡</span></span><br><span class="line">    <span class="function">RestTemplate <span class="title">restTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<p>   在Service层中通过RestTemplate实现对其他微服务发起请求</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGrade</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        String url = <span class="string">"http://eureka-grade/get/&#123;id&#125;"</span>;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一个参数为请求的url</span></span><br><span class="line"><span class="comment">         * 第二个参数为返回的值类型</span></span><br><span class="line"><span class="comment">         * 第三个参数为 Object... uriVariables参数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> restTemplate.getForObject(url , String<span class="class">.<span class="keyword">class</span>,<span class="title">id</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   在Controller中调用Service，对其他微服务进行请求：</p>
   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/getMsg"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMsg</span><span class="params">(String name,Integer id)</span></span>&#123;</span><br><span class="line">        String gradeMsg = studentService.getGrade(id);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">"是"</span> + gradeMsg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="2">
<li><p>Feign</p>
<p>Feign是SpringCloud 中服务Client端的调用框架，通常与ribbon(负载均衡)，hystrix(断路器)组合使用。</p>
<p>在某些项目中，由于遗留原因，整个系统并不是spring cloud项目，甚至不是spring项目，而使用者关注的重点仅仅是简化http调用代码的编写。</p>
<p>如果采用httpclient或者okhttp这样相对较重的框架，对初学者来说编码量与学习曲线都会是一个挑战，而使用spring中RestTemplate，又没有配置化的解决方案，由此想到是否可以脱离spring cloud，独立使用Feign。</p>
<ul>
<li>Maven依赖</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;8.18.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ul>
<li><p>自定义接口</p>
<p>通过@RequestLine指定HTTP协议和URL地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> feign.Param;</span><br><span class="line"><span class="keyword">import</span> feign.RequestLine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteService</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"GET /users/list?name=&#123;name&#125;"</span>)</span><br><span class="line">    <span class="function">String <span class="title">getOwner</span><span class="params">(@Param(value = <span class="string">"name"</span>)</span> String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>配置类</p>
<p>options方法指定<strong>连接超时时长</strong>及<strong>响应超时时长</strong>，retryer方法指定重试策略,target方法绑定接口与服务端地址。返回类型为绑定的接口类型。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">RemoteService service = Feign.builder()</span><br><span class="line">            .options(<span class="keyword">new</span> Options(<span class="number">1000</span>, <span class="number">3500</span>))</span><br><span class="line">            .retryer(<span class="keyword">new</span> Retryer.Default(<span class="number">5000</span>, <span class="number">5000</span>, <span class="number">3</span>))</span><br><span class="line">            .target(RemoteService.class, "http://127.0.0.1:8085");</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String result = service.getOwner(<span class="string">"scott"</span>);</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>业务接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RemoteService</span></span>&#123;</span><br><span class="line">    <span class="meta">@Header</span>(&#123;<span class="string">"Content-Type:application/json"</span>,<span class="string">"Accept:application/json"</span>&#125;)</span><br><span class="line">    <span class="meta">@RequestLine</span>(<span class="string">"POST /user/list"</span>)</span><br><span class="line">    <span class="function">User <span class="title">getOwner</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>配置</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">RemoteService service = Feign.builder()</span><br><span class="line">    .encoder(<span class="keyword">new</span> JacksonEncoder())			<span class="comment">//对象编码方式</span></span><br><span class="line">    .decoder(<span class="keyword">new</span> JacksonDecoder())			<span class="comment">//对象解码方式</span></span><br><span class="line">    .options(<span class="keyword">new</span> Options(<span class="number">1000</span>,<span class="number">3500</span>))		<span class="comment">//</span></span><br><span class="line">    .retryer(<span class="keyword">new</span> Retryer.Default(<span class="number">5000</span>,<span class="number">5000</span>,<span class="number">3</span>))</span><br><span class="line">    .target(RemoteService.class,"http://127.0.0.1:8085");</span><br></pre></td></tr></table></figure>







</li>
</ul>
<h3 id="2、SpringCloud-Ribbon：负载均衡"><a href="#2、SpringCloud-Ribbon：负载均衡" class="headerlink" title="2、SpringCloud Ribbon：负载均衡"></a>2、SpringCloud Ribbon：负载均衡</h3><p>​    Ribbon 是一个基于Http和TCP的客服端负载均衡工具，它是基于Netflix Ribbon实现的。</p>
<p>​    它不像spring cloud服务注册中心、配置中心、API网关那样独立部署，但是它几乎存在于每个spring cloud 微服务中。包括feign提供的声明式服务调用也是基于该Ribbon实现的。</p>
<p>​    ribbon默认提供很多种负载均衡算法，例如 轮询、随机 等等。甚至包含自定义的负载均衡算法。</p>
<p>用来实现客户端的负载均衡，支持http和udp的传输协议。无缝衔接eureka（同一家公司开发的）</p>
<p>核心：</p>
<ul>
<li>服务发现：发现依赖服务的列表</li>
<li>服务选择规则：在多个服务中如何选择一个有效服务</li>
<li>服务监听：检测失效的服务，剔除失效服务</li>
</ul>
<p>负载均衡方案：</p>
<p>第一类：集中式负载均衡, 即在consumer和provider之间使用独立的负载均衡设施(可以是硬件，如F5, 也可以是软件，如nginx), 由该设施负责把 访问请求 通过某种策略转发至provider；</p>
<p>第二类：进程内负载均衡，将负载均衡逻辑集成到consumer，consumer从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选择出一个合适的provider。</p>
<p>Ribbon就属于后者，它只是一个类库，集成于consumer进程，consumer通过它来获取到provider的地址。</p>
<p>常见的负载均衡策略：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>策略名称</th>
<th>策略对应的类名</th>
<th>实现原理</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>轮询策略（默认）</td>
<td>RoundRobinRule</td>
<td>轮询策略表示每次都顺序取下一个provider，比如一共有5个provider，第1次取第1个，第2次取第2个，第3次取第3个，以此类推</td>
</tr>
<tr>
<td>2</td>
<td>权重轮询策略</td>
<td>WeightedResponseTimeRule</td>
<td>1.根据每个provider的响应时间分配一个权重，响应时间越长，权重越小，被选中的可能性越低。<br> 2.原理：一开始为轮询策略，并开启一个计时器，每30秒收集一次每个provider的平均响应时间，当信息足够时，给每个provider附上一个权重，并按权重随机选择provider，高权越重的provider会被高概率选中。</td>
</tr>
<tr>
<td>3</td>
<td>随机策略</td>
<td>RandomRule</td>
<td>从provider列表中随机选择一个provider</td>
</tr>
<tr>
<td>4</td>
<td>最少并发数策略</td>
<td>BestAvailableRule</td>
<td>选择正在请求中的<strong>并发数最小</strong>的provider，除非这个provider在熔断中。</td>
</tr>
<tr>
<td>5</td>
<td>在“选定的负载均衡策略”基础上进行重试机制</td>
<td>RetryRule</td>
<td>1.“选定的负载均衡策略”这个策略是轮询策略RoundRobinRule <br>2.该重试策略先设定一个阈值时间段，如果在这个阈值时间段内当选择provider不成功，则一直尝试采用“选定的负载均衡策略：轮询策略”最后选择一个可用的provider</td>
</tr>
<tr>
<td>6</td>
<td>可用性敏感策略</td>
<td>AvailabilityFilteringRule</td>
<td>过滤性能差的provider,有2种： <br>第一种：过滤掉在eureka中处于一直连接失败provider <br>第二种：过滤掉高并发的provider</td>
</tr>
<tr>
<td>7</td>
<td>区域敏感性策略</td>
<td>ZoneAvoidanceRule</td>
<td>1.以一个区域为单位考察可用性，对于不可用的区域整个丢弃，从剩下区域中选可用的provider <br>2.如果这个ip区域内有一个或多个实例不可达或响应变慢，都会降低该ip区域内其他ip被选中的权重。</td>
</tr>
</tbody></table>
<h3 id="3、SpringCloud-Feign"><a href="#3、SpringCloud-Feign" class="headerlink" title="3、SpringCloud Feign"></a>3、SpringCloud Feign</h3><p>Feign是一种声明式、模板化的HTTP客户端技术(仅在consumer中使用)。</p>
<h4 id="什么是声明式调用"><a href="#什么是声明式调用" class="headerlink" title="什么是声明式调用"></a>什么是声明式调用</h4><p>声明式调用就像调用本地方法一样调用远程方法;无感知远程http请求。</p>
<p>1、Spring Cloud的声明式调用, 可以做到使用 HTTP请求远程服务时能就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP请求。</p>
<p>2、它像Dubbo一样，consumer直接调用接口方法调用provider，而不需要通过常规的Http Client构造请求再解析返回数据。</p>
<p>3、它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</p>
<h3 id="4、SpringCloud-Hystrix：断路器"><a href="#4、SpringCloud-Hystrix：断路器" class="headerlink" title="4、SpringCloud Hystrix：断路器"></a>4、SpringCloud Hystrix：断路器</h3><h3 id="5、SpringCloud-Config：分布式配置中心"><a href="#5、SpringCloud-Config：分布式配置中心" class="headerlink" title="5、SpringCloud Config：分布式配置中心"></a>5、SpringCloud Config：分布式配置中心</h3><p>为什么要使用springcloud config配置中心</p>
<p>springcloud config采用集中式的配置中心来管理每个服务的配置信息。springcloud config 配置中心在微服务分布式系统中，采用服务端和客户端来提供可拓展的配置服务，配置中心负责管理所有服务的各种环境配置文件。</p>
<p>配置中心默认采用git的方式存储配置文件，因此很容易部署和修改，有助于对环境配置进行版本管理。</p>
<p>配置中心config 解决了微服务配置的中心化、版本控制、平台独立、语言独立等问题。</p>
<p>config的特性：</p>
<ol>
<li>提供服务端和客户端的支持（springcloud config server 和 springcloud config client）</li>
<li>集中式管理分布式环境下的应用配置</li>
<li>基于Spring环境，与Spring集成</li>
<li>可用于任何语言开发的程序</li>
<li>默认实现基于git仓库的版本管理</li>
</ol>
<h3 id="6、SpringCloud-Zuul：服务网关"><a href="#6、SpringCloud-Zuul：服务网关" class="headerlink" title="6、SpringCloud Zuul：服务网关"></a>6、SpringCloud Zuul：服务网关</h3><p>网关服务，通常是外部访问服务的唯一接口，访问内部的所有服务都必须先经过网关服务。网关服务的主要功能是<strong>消息解析过滤，路由，转发</strong>等。</p>
<p>服务网关 = 路由转发 + 过滤器</p>
<ul>
<li>路由转发：接受一切外界请求，转发到后端的微服务中</li>
<li>过滤器：在服务网关中可以完成一系列的横切功能，如权限校验，限流以及监控等等，这些都可以通过过滤器实现（路由转发也是通过过滤器实现的）</li>
</ul>
<p>1、为什么需要服务网关</p>
<p>在微服务体系架构中，所谓的横切功能可以写在一下三个位置：</p>
<ul>
<li>每个服务自己进行实现</li>
<li>写到一个公共的服务中，其他需要的服务都依赖于这个服务</li>
<li>写到服务网关的前置过滤器中，所有请求过来都进行权限校验</li>
</ul>
<h3 id="7、SpringCloud-Bus：消息总线"><a href="#7、SpringCloud-Bus：消息总线" class="headerlink" title="7、SpringCloud Bus：消息总线"></a>7、SpringCloud Bus：消息总线</h3><p>SpringCloud Bus继承了市面上常用的消息代理（rabbit mq、kafka等），连接微服务系统中的所有节点，当有数据变更时候，可以通过消息代理通知微服务及时变更数据。</p>
<p>SpringCloud Bus解决的问题：</p>
<ol>
<li>微服务数据变更，及时同步的问题。</li>
</ol>
<h2 id="微服务架构的常用设计模式"><a href="#微服务架构的常用设计模式" class="headerlink" title="微服务架构的常用设计模式"></a>微服务架构的常用设计模式</h2><p>代理设计模式<br>聚合设计模式<br>链条设计模式<br>聚合链条设计模式<br>数据共享设计模式<br>异步消息设计模式</p>
]]></content>
      <categories>
        <category>JavaFrame</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
</search>
